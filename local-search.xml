<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>wsl2 ubuntu-22.04 C++环境配置</title>
    <link href="/2022/05/20/wsl2-ubuntu-22-04/"/>
    <url>/2022/05/20/wsl2-ubuntu-22-04/</url>
    
    <content type="html"><![CDATA[<p>记录配置的过程，以备不时之需</p><span id="more"></span><p>三条命令换源，并备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak<br>sudo sed -i &#x27;s/archive.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apt/sources.list<br>sudo sed -i &#x27;s/security.ubuntu.com/mirrors.tuna.tsinghua.edu.cn/g&#x27; /etc/apt/sources.list<br></code></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习记录</title>
    <link href="/2022/05/18/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/05/18/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>这几天再B站大学看了一边小甲鱼的C++快速入门，做个记录以便回忆复习。<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=43&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Ps411w73m?p=43&amp;spm_id_from=pageDriver</a></p><p>视频里小甲鱼这么说</p><ul><li>专注那些我们应该去做的事情，并坚持下去！</li><li>一片飘落的树叶最终落在哪里，决定他的是上帝。至于我们，正如那片树叶一般，去努力想着我们的目标飞行就足够了</li><li>至于上帝的眷顾嘛？大家都知道，机会总是留给有准备的人。只有你朝着梦想去努力追求，才有可能实现梦想，而在困难与挫折面前停滞不前，忧虑苦闷肯定不属于追求梦想的范畴！</li></ul><span id="more"></span><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数的重载的规则：</p><ul><li>函数名称必须相同。</li><li>参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。</li><li>函数的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为函数的重载。</li></ul><h3 id="C-是如何做到函数重载的"><a href="#C-是如何做到函数重载的" class="headerlink" title="C++ 是如何做到函数重载的"></a>C++ 是如何做到函数重载的</h3><p>C++代码在编译时会根据参数列表对函数进行重命名，例如<code>void Swap(int a, int b)</code>会被重命名为_<code>Swap_int_int</code>，<code>void Swap(float x, float y)</code>会被重命名为_<code>Swap_float_float</code>。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做<strong>重载决议（Overload Resolution）</strong>。</p><p>从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p><p>更详细的细节：<a href="https://blog.csdn.net/qq_41854911/article/details/119360742">https://blog.csdn.net/qq_41854911/article/details/119360742</a></p><h2 id="联合Union"><a href="#联合Union" class="headerlink" title="联合Union"></a>联合Union</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">mima</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> brithday;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ssn;<br>    <span class="hljs-type">char</span>* pet;<br>&#125;;<br></code></pre></td></tr></table></figure><p>联合一次只能对一个成员赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">mima mima_1;<br><br>std::cout&lt;&lt;<span class="hljs-string">&quot;hello world!&quot;</span>&lt;&lt;endl;<br><br>mima_1.brithday = <span class="hljs-number">19883101</span>;<br>std::cout&lt;&lt;mima_1.brithday&lt;&lt;endl;<br>mima_1.pet =(<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;Chaozai&quot;</span>;<br>std::cout&lt;&lt;mima_1.pet&lt;&lt;endl;<br>std::cout&lt;&lt;mima_1.brithday&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="enum-别名"><a href="#enum-别名" class="headerlink" title="enum 别名"></a>enum 别名</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">weekdays</span>&#123;Monday,Tuesday,Wednesday,Thursday,Friday&#125;;<br>   weekdays today;<br>   <br>   today = Monday; <span class="hljs-comment">//输出0</span><br>   std::cout &lt;&lt; today &lt;&lt;std::endl;<br><br>   today = Thursday; <span class="hljs-comment">//输出3</span><br>   std::cout&lt;&lt;today &lt;&lt;std::endl;<br></code></pre></td></tr></table></figure><blockquote><p>可以配合switch case 使用</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p>在创建对象，系统会调用一个特殊的方法，即构造器</p></blockquote><p>构造函数与以下方式的常规函数不同：</p><ul><li>构造函数与类本身具有相同的名称</li><li>构造函数没有返回类型</li><li>创建对象时会自动调用构造函数。</li><li>如果我们没有指定构造函数，C ++编译器会为我们生成一个默认构造函数（不需要参数并且有一个空体）。</li></ul><p>….</p><p>创建构造器，需要先把它的声明添加到类里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br><span class="hljs-built_in">Car</span>(<span class="hljs-type">void</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在结束声明后开始定义构造器本身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Car::<span class="hljs-built_in">Car</span>(<span class="hljs-type">void</span>)<br>&#123;<br>    color = <span class="hljs-string">&quot;WHITE&quot;</span>;<br>    engine = <span class="hljs-string">&quot;V8&quot;</span>;<br>    Wheel = <span class="hljs-number">4</span>;<br>    gas_tank = FULL_GAS;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当你的类中没有定义构造器，编译器就会使用如下的语法定义一个： </p><p>ClassName::ClassName(){}</p><h2 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h2><p>构造器用来完成事先的初始化和准备工作（申请分配内存），析构器用来完成事后所必须的清理工作（清理内存）。</p><p>构造器和析构器两者相辅相成，两者有许多共同之处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span><br>&#123;<br>    <span class="hljs-built_in">Car</span>(<span class="hljs-type">void</span>)<br>    ~<span class="hljs-built_in">Car</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在较为复杂的类里，析构器往往至关重要（可能引起内存泄露）。</p><blockquote><p>eg某个类申请了内存，必须用析构器释放</p></blockquote><h2 id="This指针"><a href="#This指针" class="headerlink" title="This指针"></a>This指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<br><span class="hljs-type">char</span> fishc;<br><span class="hljs-built_in">Human</span>(<span class="hljs-type">char</span> fishc);<br>&#125;<br>Human::<span class="hljs-built_in">Human</span>(<span class="hljs-type">char</span> fishc)&#123;<br>    fishc = fishc;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时<code>fishc = fishc</code> 我们无法得知哪个fishc 是类中的属性，哪个fishc是参数，这时候就需要this指针，<code>this-&gt;fishc = fishc</code>赋值后this对应fishc为对象中的属性。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>继承机制可以创建一个类的层叠层次结构，使得每一个子类均继承在它的基类里定义的方法和属性。</p><blockquote><p> 如以动物为基类的类可以有猪和乌龟两个子类</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> : <span class="hljs-keyword">public</span> SuperClass&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pig</span>:<span class="hljs-keyword">public</span> Animal&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="继承机制中的构造器和析构器"><a href="#继承机制中的构造器和析构器" class="headerlink" title="继承机制中的构造器和析构器"></a>继承机制中的构造器和析构器</h2><p>按原来的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Animal</span>(std::string theName);<br>    std::string name;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pig</span> : <span class="hljs-keyword">public</span> Animal&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Pig</span>(std::string theName);<br>&#125;<br></code></pre></td></tr></table></figure><p>应该的写法：将pig的构造器继承于animal的构造器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">Animal::<span class="hljs-built_in">Animal</span>(std::string theName)&#123;<br>    name = theName<br>&#125;<br>Pig::<span class="hljs-built_in">Pig</span>(std::string theName) : <span class="hljs-built_in">Animal</span>(theName)&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初学者注意"><a href="#初学者注意" class="headerlink" title="初学者注意"></a>初学者注意</h2><ul><li>基类和子类之间的关系应该自然而清晰</li><li>构造器的设计要越简明越好</li><li>在设计、定义和使用一个类的时候，应该让它的每个组成部分简单到不能再简单</li><li>析构器的基本用途是对前面做的事进行清理。尤其是使用了动态内存的程序，析构器将至关重要。</li></ul><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>所谓的访问控制，就是C++提供了一种用来保护类里的方法和属性的手段。保护是指对谁可以调用某个方法和访问某个属性加上一个限制，如果某对象试图调用一个它无权访问的函数，编译器将报错</p><table><thead><tr><th align="center">级别</th><th align="center">允许谁来访问</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">任何代码</td></tr><tr><td align="center">protected</td><td align="center">这个类本身和它的子类</td></tr><tr><td align="center">private</td><td align="center">只有这个类本身</td></tr></tbody></table><p>question:下列代码中的public的含义</p><p><code>--- class Pig : public Animal &#123;...&#125;</code></p><ul><li><p>C++不仅允许你对类里定义的方法和属性实施访问控制，还允许你控制子类可以访问基类里的哪些方法和属性。</p></li><li><p>public</p><ul><li>是再告诉编译器：继承的方法和属性的访问级别不发生任何改变——即public仍可以被所有代码访问，protected 只能由基类的子类访问，private则只能由基类本身访问。</li></ul></li><li><p>protected</p><ul><li>子类外部的代码无法通过子类去访问基类中的public</li></ul></li><li><p>private </p><ul><li>从基类继承来的每一个成员都当成private来对待，者意味着只有这个子类可以使用它从基类继承来的元素</li></ul></li></ul><blockquote><p>一般只用public …….</p></blockquote><h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>当我们的基类里提供了一个通用的函数，但在它的某个子类里需要修改这个方法的实现，在C++里，覆盖（overriding）就可以做到。</p><p>讲基类中的函数在子类中进行再一次的声明，再一次的实现就可以将继承来的函数覆盖。</p><h2 id="重载方法"><a href="#重载方法" class="headerlink" title="重载方法"></a>重载方法</h2><p>简化编程互作和提高代码可读性的另一种方法是对方法进行重载。</p><p>重载是同一个类之间，覆盖是基类和子类之间。</p><h2 id="友元关系"><a href="#友元关系" class="headerlink" title="友元关系"></a>友元关系</h2><p>可能在某些场合，一个完全无关的类由于某些特殊原因需要访问到某个protected成员，甚至某个private成员，那该怎么办？</p><p><strong>友元关系</strong>是类之间的一种特殊关系，这种关系不仅允许友元类访问对方的public方法和属性，还允许友元访问对方的protected和private方法和属性。</p><p> 声明一个友元关系只需要在类声明里的一个地方加上一条<code>friend class **</code>就行。</p><h2 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Pet</span>(std::string theName);<br>        ~<span class="hljs-built_in">Pet</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">protected</span>:<br>        std::string name;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><p>只能从<code>getCount()</code> 的接口访问count的值，用static 关键字后，会在静态存储区分配内存</p><h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><h2 id="C-内存分配方式"><a href="#C-内存分配方式" class="headerlink" title="C++内存分配方式"></a>C++内存分配方式</h2><p>一个由C&#x2F;C++编译的程序占用的内存分为以下几个部分：<br>1、栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap） ： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。（malloc &amp; new）<br>3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、常量存储区 ：常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区：存放函数体的二进制代码。</p><blockquote><p><a href="https://fishc.com.cn/blog-9-1097.html">https://fishc.com.cn/blog-9-1097.html</a></p></blockquote><h2 id="容器——向量Vector"><a href="#容器——向量Vector" class="headerlink" title="容器——向量Vector"></a>容器——向量Vector</h2><p>。。。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>。。。。</p><h2 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C++预处理器"></a>C++预处理器</h2><ul><li>有时候在头文件较多时，多个文件之间互相include，这时有些类、变量、函数等等会被声明多次，这种声明将导致编译器报错。</li><li>利用C++预处理器，我们可以让头文件只在这个类还没有被声明过的情况下才声明它。</li></ul><p><strong>预处理器的条件指令</strong></p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>#if</td><td>如果表达式为真，执行代码</td></tr><tr><td>#else</td><td>如果前面的#if表达式为假，执行代码</td></tr><tr><td>#elif</td><td>相当于“elseif”</td></tr><tr><td>#endif</td><td>用来标志一个条件指令的结束</td></tr><tr><td>#ifdef</td><td>如果本指令所引用的定义已存在，执行代码</td></tr><tr><td>#ifndef</td><td>如果本指令所引用的定义不存在，执行代码</td></tr></tbody></table><p><strong>可以用预处理来进行代码注释</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">// 一堆代码1</span><br><span class="hljs-comment">// 一堆代码2</span><br><span class="hljs-comment">// 一堆代码3</span><br><span class="hljs-comment">// 一堆代码4</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>可以实现相同量只定义一次</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LOVE_FISHC</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOVE_FISHC</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果LOVE_FISHC没有定义则定义之。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LOVE_FISHC</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOVE_FISHC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;...&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果LOVE_FISHC还没有定义，则定义一次LOVE_FISHC,然后对Rational.h做出声明将.改为下划线”RATIONAL_H”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> RATIONAL_H</span><br>#DEFINE RATIONAL_H<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">rational</span>&#123;...&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><strong>命名空间</strong></h2><p>创建的每一个类、函数和变量都只能在一定的区域内使用，而我们所知道最大的区域是全局作用域，最小的区域是一个代码块，eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>命名空间其实就是由用户定义的范围，同一个命名空间里的东西只要在这个命名空间有独一无二的名字就行了。如果某个程序有许多不同的头文件或已编译文件，它们又各自声明了许多的东西，命名空间可以为它们提供保护。</p><p>创建命名空间的方法如下（括起来就行，最末尾不要加分号）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> myNamespace<br>&#123;<br><span class="hljs-comment">//全部东西</span><br>&#125;<br></code></pre></td></tr></table></figure><p>命名空间可以让你使用同一个标识符而不会导致冲突：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> author<br>&#123;<br>    std::string person;<br>&#125;<br><span class="hljs-keyword">namespace</span> programmer<br>&#123;<br>    std::string person;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链接和作用域"><a href="#链接和作用域" class="headerlink" title="链接和作用域"></a>链接和作用域</h2><p>当你同时编译多个文件时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -o test main.cpp rational.cpp<br></code></pre></td></tr></table></figure><p>每个源文件都被称为一个翻译单元（translation unit)，在某一个翻译单元里定义的东西在另一个翻译单元里使用正是链接发挥作用的地方。</p><p>作用域、链接和存储类是相互关联的概念，它们有许多共同的术语，只是观察和描述问题的角度不同罢了。</p><h2 id="存储类（storage-class"><a href="#存储类（storage-class" class="headerlink" title="存储类（storage class)"></a>存储类（storage class)</h2><ul><li>每一个变量都有一个存储类，它决定着程序将把变量的值存储在计算机的什么地方、如何存储，以及变量应该有着怎样的作用域。</li><li>默认的存储类是<strong>auto</strong>(自动)，但是我们不会经常看到这个关键字，因为它是默认的</li><li>自动变量存储在称为栈（stack)的临时内存里并有着最小的作用域，当程序执行到语句块或函数末尾的右花括号时，它们将被系统回收（栈回收），不复存在。</li><li>与auto不同的是<strong>static</strong>,static变量在程序的声明周期内将一直保有它的值而不会消亡，因为它们是存储在静态存储区，生命周期为从申请到程序退出（和全局变量一样）。</li><li>static变量可以有external或internal链接。</li><li>第三种存储类是<strong>extern</strong>,它在有多个翻译单元时非常重要。这个关键字用来把另一个翻译单元里的某个变量声明为本翻译单元里的一个同名全局变量。</li><li>编译器不会为extern变量分配内存，因为在其他地方已经为它分配过内存。</li><li>用extern关键字相当于告诉编译器：“请相信我，我发誓我知道这个变量在其他翻译单元里肯定存在，它只是没在这个文件里声明。”</li><li>存储类<strong>register</strong>,它要求编译器把一个变量存储在CPU的寄存器里。但有着与自动变量相同的作用域。</li><li>register变量存储速度最快，但有些编译器可能不允许使用这类变量</li></ul><h2 id="变量的链接和作用域"><a href="#变量的链接和作用域" class="headerlink" title="变量的链接和作用域"></a>变量的链接和作用域</h2><p>使用编译器编译程序时，实际有三步</p><ol><li>执行预处理器指令（带#号的）</li><li>把.cpp文件编译成.o文件</li><li>把.o文件链接成一个可执行文件。</li></ol><p>链接分为三种情况：</p><ol><li>外链接（external)</li><li>内链接  (internal)</li><li>无链接  (none)</li></ol><p><strong>外链接</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">eg.<br><span class="hljs-comment">//this.cpp</span><br><span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//that.cpp</span><br><span class="hljs-type">int</span> i2 = i1;<br></code></pre></td></tr></table></figure><p>在编译that.cpp文件时，编译器并不知道i1变量的存在。为了解决这个问题，我们可以在that.cpp里使用extern关键字去访问第一个翻译单元的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//this.cpp</span><br><span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//that.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i1;<br><span class="hljs-type">int</span> i2 = i1;<br></code></pre></td></tr></table></figure><p><strong>内链接</strong></p><p>内链接的含义：在某个翻译单元里定义的东西只能在翻译单元里使用，在任何函数以外定义的静态变量都有内链接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//this.cpp</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> d = <span class="hljs-number">8</span>;<br><span class="hljs-comment">//that.cpp</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> d = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure><p><strong>无链接</strong></p><p>在函数里定义的变量只存在于该函数的内部，根本没有任何链接（none)</p><h2 id="函数模板（泛型编程）"><a href="#函数模板（泛型编程）" class="headerlink" title="函数模板（泛型编程）"></a>函数模板（泛型编程）</h2><p>范型编程技术支持程序员创建函数和类的蓝图，而不是具体的函数和类。</p><p>基本的函数模板语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>第一行代码里，尖括号里的一个<code>classT</code> ，用来告诉编译器：字母T将在接下来的函数里代表一种不确定的数据类型。</li><li>关键字class并不意味着这个是类，这只是一种约定俗成的写法。</li><li>在告诉计算机T是一种类型之后，就可以像对待一种普通数据类型那样使用它了。</li></ol><p>for example:</p><p>交换两个变量的值是几乎所有程序的基本操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;a ,<span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp = a;<br>    a = b;<br>    b = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想用这个函数交换两个double类型的变量的值，我们需要增加一个swap(double &amp;a, double &amp;b)函数，因为C++支持函数重载，但是我们不得不为每一种数据格式写一种函数。此时，我们只需要为编译器准备一个<strong>模板</strong>即可。</p><p><strong>需要注意的地方：</strong></p><ul><li>创建模板时，还可以用<code>template&lt;typename T&gt;</code>来代替<code>template&lt;class T&gt;</code>，他们的含义是一样的。</li><li>注意，<code>template&lt;class T&gt;</code>中的class并不意味着T只能是一个类</li><li>不要把函数模板分成原型和实现两个部分（全写一起）</li><li>为明确地表明<code>swap（）</code>是一个函数模板，还可以使用<code>swap&lt;int&gt;(i1,i2)</code>语法来调用这个函数。这将明确地告诉编译器它应该使用哪一种类型。</li></ul><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p> 类模板与函数模板非常相似：同样是由你编写一个类的模板，再由编译器在你第一次使用这个模板时生成实际代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br><br>&#123;<br><span class="hljs-built_in">MyClass</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a , T &amp;b)</span>；</span><br><span class="hljs-function">&#125;；</span><br></code></pre></td></tr></table></figure><p>构造器的实现将是下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyClass&lt;T&gt;::<span class="hljs-built_in">MyClass</span>()<br>&#123;<br>    <span class="hljs-comment">//初始化操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>MyClass</code>是一个类模板，所以不能只写出<code>MyClass::MyClass()</code>,编译器需要你在这里给出一种与<code>MyClass()</code>配合使用的数据类型，必须在尖括号里提供它。因为没有确定的数据类型可以提供，所以使用一个T作为占位符即可。</p><p><strong>注意：</strong></p><p>C++并没有限制只能使用一个类型占位符，如果类模板需要一种以上的类型，根据具体情况多使用几个占位符即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>    &#123;<br>        <span class="hljs-comment">//... ...</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>在实例化的时候我们只需要这么做： <code>MyClass&lt;int,float&gt;myClass;</code></p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>引入内联函数的目的是解决程序中函数调用的效率问题。</p><p>内联函数从源代码看有函数的结构，而在编译后，却不具备函数的性质。编译时，类似宏替换，使用函数体替换调用处的函数名。</p><p>一般在代码中用inline修饰，但能否形成内联函数，需要看编译器对该函数定义的具体处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(intx ,<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y+z;<br>&#125;<br></code></pre></td></tr></table></figure><p>在程序中，调用其函数时，该函数在编译时被替代，而不像一般函数那样是在运行时被调用。</p><p>在创建类模板时，避免类声明和类定义相分离的一个好办法是使用内联方法。</p><p>在类里，内联方法的基本含义是在声明该方法的同时还对它进行定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <span class="hljs-built_in">Person</span>(std::string name)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;name = name;<br>    &#125;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了可以更好地帮助编译器处理类模板之外，使用内联方法还有一个很好的作用：可以让你少打些字并让源代码的可读性变得更好（把所有东西都直接写到类里）。</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就自动调用该函数，以实现相应的运算。，也就是说运算符的重载是定义函数实现的。<strong>运算符重载实质上是函数的重载。</strong></p><p> 重载运算符的函数一般格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">函数类型 <span class="hljs-keyword">operator</span> 运算符名称（形参表列）<br>&#123;<br>    对运算符的重载处理<br>&#125;<br></code></pre></td></tr></table></figure><p>例如我们可以重载运算符+，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span> a ,<span class="hljs-type">int</span> b)<br>&#123; <br>    <span class="hljs-keyword">return</span>(a-b);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载。</strong></li><li>除了以下五个不允许重载外，其他运算符都允许重载。<ul><li>.（成员访问运算符）</li><li>.*（成员指针访问运算符）</li><li>::（域运算符）</li><li>sizeof（尺寸运算符）</li><li>?:（条件运算符）</li></ul></li><li>重载不能改变运算符运算对象（操作数）个数</li><li>重载不能改变运算符的优先级别  </li><li>重载不能改变运算符的结合性</li><li>重载运算符的函数不能有默认的参数。</li><li>重载运算符必须和用户定义的自定义类型的对象一起使用。也就是说，参数不能全部都是C++的标准类型，这样约定是为了防止用户修改用于标准类型结构的运算符性质）。</li></ol><h3 id="运算符重载函数作为类友元函数"><a href="#运算符重载函数作为类友元函数" class="headerlink" title="运算符重载函数作为类友元函数"></a>运算符重载函数作为类友元函数</h3><p><strong>“+”运算符是双目运算符，为什么例子中的重载函数只有一个参数？</strong></p><p>答：实际上，运算符重载函数有两个参数，但由于重载函数是Complex类中的成员函数，有一个参数是隐含着的，运算符函数是用this指针隐式地访问类对象的成员的。</p><ul><li><code>return Complex(real+c2.real,imag+c2.imag);</code></li><li><code>return Complex(this-&gt;real+c2.real,this-&gt;imag+c2.imag);</code></li><li><code>return Complex(c1.real+c2.real,c1.imag+c2.imag);</code></li></ul><p>运算符重载除了可以作为类的成员函数外，还可以式非成员函数：放在类外，做Complex类的友元函数存在</p><h4 id="一些小TIPS"><a href="#一些小TIPS" class="headerlink" title="一些小TIPS"></a><strong>一些小TIPS</strong></h4><ul><li>千万不要仅仅因为“我懂得这么做”而去重载一个操作符，应该只在有必要的时候，比如实现一种新的数据类型时，才重载操作符。</li><li>重载操作符的目的是为了让代码更容易阅读和理解。令人遗憾的是，这个技巧常常被人滥用。</li><li>在重载操作符时，千万不要让它们失去原始的意义，你完全重载”+”然后对它进行减法操作，但这决不是创意的表现，在公司这员工必须被开除。</li></ul><h3 id="重载-lt-lt-操作符（插入器）"><a href="#重载-lt-lt-操作符（插入器）" class="headerlink" title="重载&lt;&lt;操作符（插入器）"></a>重载&lt;&lt;操作符（插入器）</h3><blockquote><p>把一个数据插入到流中的函数都是插入器</p></blockquote><h2 id="多继承-multi-inheritance"><a href="#多继承-multi-inheritance" class="headerlink" title="多继承(multi inheritance)"></a>多继承(multi inheritance)</h2><p><strong>什么时候需要用多继承？</strong></p><p>一个student不仅当student,还当teacher（助教），则student同时继承teacher和student类，此时就需要使用多继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TeachingStudent</span> : <span class="hljs-keyword">public</span> Student, <span class="hljs-keyword">public</span> Teacher<br>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>要求：创建一个由<code>Person</code>,<code>Teacher</code>,<code>Student</code>和<code>Teachingstudent</code>构成的类层次关系。</p><h2 id="虚继承（virtual-inheritance"><a href="#虚继承（virtual-inheritance" class="headerlink" title="虚继承（virtual inheritance)"></a>虚继承（virtual inheritance)</h2><p>在<code>TeachingStudent</code>继承自<code>Student</code>和<code>Teacher</code>时，可能有继承的同名属性的情况</p><p>通过虚继承某个基类，就是在告诉编译器：从当前这个类再派生出来的子类只能拥有那个基类的一个实例。</p><p>虚继承的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Person<br>&#123;...&#125;<br></code></pre></td></tr></table></figure><h2 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *x<br>x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1000</span>]<br><span class="hljs-keyword">delete</span>[] x;<br>x = <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p>如果地址值(x)丢失了，则会发生内存泄漏,地址值会因为很多原因丢失，比如因为一个指针变量被无意中改写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *x;<br>x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3000</span>];<br>x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4000</span>];<br><span class="hljs-keyword">delete</span>[] x;<br>x = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>这是导致内存泄漏的情况之一。</p><p>另一种导致内存泄漏的情况是用来保存内存块的地址的指针变量作用域问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    My Class *x;<br>    x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当foo()函数结束时，指针变量x将超出它的作用域，这意味着它将不复存在，它的值会丢失。</p><p>两种方法解决这种情况：</p><p>第一种是在return 语句之前的某个地方插入一条delete x语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyClass *x;<br>    x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();<br>    <span class="hljs-keyword">delete</span> x;<br>    x = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种是让函数把内存块的地址返回给它的调用者：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">MyClass* <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyClass* x;<br>    x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();<br>    <br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态内存不存在作用域的问题，一旦被分配，内存块就可以在程序的任何地方使用。</p><p>因为动态内存没有作用域，所以必须由程序员来跟踪它们的使用情况，并在不需要用到它们的时候把它们及时归还给系统。</p><p>特别需要注意，虽然动态分配的内存块没有作用域，但是用来保存其地址的指针变量是受作用域影响的。</p><p>程序出错</p><p>程序出错分为两类：</p><ul><li>编译时错误</li><li>运行时错误</li></ul><p><strong>建议：</strong></p><ol><li>保持一种风格，一旦决定要如何命名变量和函数、要按何种格式编写代码、如何缩进代码块等，就应该一种保持下去。</li><li>认真对待编译器给出的错误&#x2F;警告信息</li><li>三思而后行：开始写代码前先画流程图</li><li>注意检查最基本的语法</li><li>把可能有问题的代码行改为注释</li><li>换一个环境或者开发工具试试</li><li>检查自己是否已经把所有必要的头文件都include进来，调用不熟悉的函数前查看相关文档，确定该函数需要哪些头文件。</li><li>留意变量的作用域和命名空间</li><li>休息一下</li><li>多使用调试工具，要多使用调试器。</li><li>避免错误的另一个办法就是把调试好的代码另外保存起来并不再改动它，然后把代码划分成各个模块，用它们（在你能确保它们都没问题的情况下）搭建新的应用程序，会让你减少很多开发和调试的时间。</li></ol><p><strong>运行时错误</strong></p><ul><li>保持并培养一种良好的变成风格</li><li>多用注释，用好注释，要注意注释和代码保持同步，也不要做无谓的注释。</li><li>注意操作符的优先级，做保险的方法是用括号来确保这种</li><li>千万不要忘记对用户输入和文件输入进行合法性检查</li><li>不要做任何假设</li><li>把程序划分成一些比较小的单元模块测试，程序越长就越难以测试，只要条件允许，就应该把一个比较大的程序划分成一些了比较小的单元模块来分别加以测试。</li></ul><p><strong>让函数返回错误代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( condition )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>eg.在写一个factorial函数的时候可能会出现超界的情况，这时候我们可以引用climits头文件，该头文件列出了各种数据类型在给定操作系统上的取值范围，并且把每种数据类型的最大可取值和最小可取值都分别定义为一个常量供我们比较。</p><p>SHORT_MAX 整数最大值,    SHORT_MIN 整数最小值, USHORT_MAX 无符号整数最大值</p><h2 id="assert函数和异常捕获"><a href="#assert函数和异常捕获" class="headerlink" title="assert函数和异常捕获"></a>assert函数和异常捕获</h2><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><ul><li>C语言和C++都有一个专门为调试而准备的工具函数，就是assert()函数</li><li>这个函数在C语言的assert.h库文件里定义，所以包含到C++程序里我们用以下的语句：<ul><li><code>#include&lt;cassert&gt;</code></li></ul></li><li>assert()函数需要一个参数，它将测试这个输入参数的真&#x2F;假状态</li></ul><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>基本使用思路：</p><ol><li>安排一些C++代码（try语句）去尝试某些事——尤其是那些可能会失败的事（比如打开一个文件或申请一些内存。</li><li>如果发生问题，就抛出一个异常（throw)</li><li>再安排一些代码(catch语句)去捕获这个异常并进行相应的处理。</li></ol><p>捕获异常的基本语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">//Do something</span><br>    <span class="hljs-comment">//Throw an exception an error.</span><br>&#125;<br><span class="hljs-keyword">catch</span><br>&#123;<br>    <span class="hljs-comment">//Do whatever.</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Pay attention! 每条try语句至少要有一条配对的catch语句。必须定义catch语句以便让它接受一个特定类型的参数。</li><li>C++还允许我们定义多条catch语句，让每条catch语句分别对应着一种可能的异常类型:<ul><li>catch(int e) { …}</li><li>catch(bool e) {…}</li><li>catch(…) {…}</li></ul></li><li>最后一条可以捕获任意的异常</li><li>在程序里，我们用throw保留字来抛出一个异常：throw 1; </li><li>在某个try语句块里执行过throw语句，它后面的所有语句（截止到这个try语句末尾）将永远不会被执行。</li><li>与使用一个条件语句或return语句相比，采用异常处理机制的好处是它可以把程序的正常功能和逻辑与出错处理部分清晰地划分开而不是让它们混杂在一起。</li></ul><h3 id="如何让函数抛出异常"><a href="#如何让函数抛出异常" class="headerlink" title="如何让函数抛出异常"></a>如何让函数抛出异常</h3><p>定义一个函数时明确地表明你想让它抛出一个异常，为了表明你想让它抛出哪种类型的异常，可以使用如下所示语法：</p><p>​<code>type functionName(arguments)  throw(type);</code></p><p>如果没有使用这种语法来定义函数，就意味着函数可以抛出任意类型的异常。</p><p>注：有些编译器不支持这种语法，则可胜利throw(type)部分。</p><p><strong>TIPS:</strong></p><ol><li>只用异常处理来确定可能不正常的情况</li><li>构造器和析构器最好不要使用异常</li><li>如果try语句无法找到与之匹配的catch语句块，它抛出的异常将中止程序的执行。</li><li>在C++标准库里有一个名为exception的文件，该文件声明了一个exception的基类。可以用这个基类创建个人的子类以管理异常，有经验的程序员常常这么做，而如此抛出或捕获exception类或其子类的对象。</li><li>如果你打算使用对象作为异常，请记住这样一条原则：以“值传递”方式抛出异常，以“引用传递”方式捕获异常对象。</li></ol><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p>new可以申请动态内存并返回动态内存的地址</p><ul><li>如果没有足够的可用内存空间？<ul><li>那么new语句将抛出std::bad_alloc异常！</li></ul></li><li>在用完内存块之后，应该用delete语句把它还给内存池。另外作为一种附加的保险措施，在释放了内存块之后还应该把与之关联的指针设置为NULL。</li></ul><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span> []x;<br>x = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>在delete后加上一个[]来表示删除一整个数组（回收该数组对应的内存）</p><h2 id="副本构造器"><a href="#副本构造器" class="headerlink" title="副本构造器"></a>副本构造器</h2><p>编译器将生成必要的代码把“源”对象各属性的值分别赋值给“目标”对象的对应成员。这种赋值行为称之为逐位赋值（bitwise copy) </p><p>这种行为在绝大多数场合都没有问题，但如果某些成员变量是指针的话，问题就来了：成员对象进行逐位复制的结果是你将拥有两个一模一样的实例，而这两个副本里的同名指针会指向相同的地址。在删除其中一个对象时，它包含的指针也将被删除，但另一个副本（对象）还在引用这个指针，就会出问题！</p><p>分析如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">MyClass obj1;<br>MyClass obj2;<br>obj2 = obj1;<br></code></pre></td></tr></table></figure><p>前两行代码创建出了两个MyClass类的实例obj1和obj2。第三行代码把obj1的值赋值给了obj2，这里就会埋下祸根！如何才能截获这个赋值操作并告诉它应该如何处理那些指针呢？</p><h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>我们可以重载“&#x3D;”操作符，在其中对指针进行处理：</p><p>—<code>MyClass &amp;operator = (const MyClass &amp;rhs);</code></p><p>上述语句告诉问这个方法所预期的输入参数应该是一个<code>MyClass</code>类型的、不可改变的引用。</p><p>用<code>const</code>把那个引用声明为一个常量确保万无一失（以免被copy的对象被修改）。</p><p>改写下测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyClass obj1;<br>MyClass obj2 = obj1;<br></code></pre></td></tr></table></figure><ul><li>这与之前的区别很细微，刚才是先创建两个对象，然后再把obj1赋值给obj2.</li><li>现在是先创建一个实例obj1，然后再创建实例obj2的同时用obj1的值对它进行初始化。</li><li>虽然看上去差不多，但是编译器却生成完全不同的代码：编译器将在MyClass类里寻找一个副本构造器(copy constructor),如果找不到，它会自行创建一个。</li><li>即使我们对赋值操作符进行了重载，由编译器创建的副本构造器仍以”逐位复制”的方式把obj1赋值给obj2。</li><li>在这种情况下，即使已经在类中重载了赋值操作符，暗藏隐患的“逐位复制”行为还是会发生。</li><li>因此要亲自定义一个副本构造器，而不是让编译器自动生成。<ul><li><code>MyClass(const MyClass &amp;rhs);</code></li></ul></li><li>这个构造器需要一个固定不变<code>（const)</code>的<code>MyClass</code>类型的引用作为输入参数，就像赋值操作符那样。<strong>因为它是一个构造器，因此不需要返回类型</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>姚玉峰医生个人分享</title>
    <link href="/2022/05/14/%E5%A7%9A%E7%8E%89%E5%B3%B0%E5%8C%BB%E7%94%9F%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/"/>
    <url>/2022/05/14/%E5%A7%9A%E7%8E%89%E5%B3%B0%E5%8C%BB%E7%94%9F%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>姚玉峰医生是浙江大学医学院附属邵逸夫医院眼科主任，本文记录了姚医生的人生体会、工作体会。</p><span id="more"></span><h1 id="姚医生个人分享"><a href="#姚医生个人分享" class="headerlink" title="姚医生个人分享"></a>姚医生个人分享</h1><img src="/2022/05/14/%E5%A7%9A%E7%8E%89%E5%B3%B0%E5%8C%BB%E7%94%9F%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/3bc87eada3504af0811f41e63c43ac24.jpeg" class="" title="3bc87eada3504af0811f41e63c43ac24"><h2 id="我对人生的理解"><a href="#我对人生的理解" class="headerlink" title="我对人生的理解"></a>我对人生的理解</h2><ul><li>我认为，人生就是在生存和追求的时序中，与不断遇到的障碍、面临的挑战，去跨越、去克服的过程在人生的前面，无论那个阶段，包括工作的每一个环节， 时刻存在着明明暗暗的群山沟壑、暗流险滩，每迈出一步，每完成一个任务和一项工作，想能够顺利进展，达到满意，都是不容易的</li><li>人生的旅途有点像登山，时刻有让人有喘不过气来的感觉，深感压力和对未知的畏惧，总会出现不如躺平算了的想法</li><li>但是，<strong>只要生命在延续，人生的旅途是无法停歇、躺平的。你如果选择原地不动去享受轻松，就等于让生命静止。</strong></li><li><strong>你选择自己生命处于静止状态，但你所接触到的人，你所链接的每一个环节，你的团队甚至你的家人都会受你躺平的牵累，会让生活、工作、关联的人掉链子</strong></li><li>然而登山到了一定阶段后，每登高一步、 再上升一个台阶，都需要再屏住一一口气，再咬紧一下牙，需要再付出一份艰辛，需要再去克服一段困难</li><li>我认为，<strong>所谓的幸福，就是当障碍被跨越，挑战被解除时的那个瞬间感受</strong></li><li><strong>既然想走完自己满意的人生，就唯有坚持、忍耐和毅力，除此之外，别无它途，这是生存的必需</strong></li></ul><h2 id="我对生命、价值、幸福的理解"><a href="#我对生命、价值、幸福的理解" class="headerlink" title="我对生命、价值、幸福的理解"></a>我对生命、价值、幸福的理解</h2><ul><li>生命的意义,体现在价值上</li><li>对价值进行度量的方法，叫做价值观</li><li>作为一个群体或者社会，需要大家共同认同的价值观。价值观最本质，最核心的部分，就是核心价值观</li><li>社会教育，是让人懂得核心价值观和履行核心价值观的意义</li><li>个人的幸福，只有通过学习掌握生存技巧和提高生存能力，才能幸福;个人的价值只有体现在通过自身努力去增进全体社会福祉,才能让人的生命价值得到展现</li><li>学习，是为了幸福</li><li>幸福，是因为发挥了自己的能力，增加社会福祉，获得社会的认可,体现生存的意义和自我价值的社会实现</li></ul><h2 id="谈医生工作"><a href="#谈医生工作" class="headerlink" title="谈医生工作"></a>谈医生工作</h2><ul><li>医疗,是项良心活</li><li>个人从讲入这个职业那一刻起，就需要从自心底里生发出对生命的敬畏，对人生</li><li>艰难的悲悯,对他人痛苦的同情</li><li>医德，就是对维护生命珍贵的责任，对为了保全人生的健康所需要的知识和技能的不懈追求,对生命所应有的希望的担当</li><li>当我们放下工作，回到家里之后，自己进入独处的安静时刻,细细回想经历的每一个病人，扪心自问，是否上可以对得起苍天,下可以对得起具体的病人，内能够对得起良知?如果做到了，灵魂就获得了安宁</li><li>灵魂的安宁,是生命追求的最佳状态</li></ul><h2 id="人为什么需要谦卑"><a href="#人为什么需要谦卑" class="headerlink" title="人为什么需要谦卑?"></a>人为什么需要谦卑?</h2><ul><li>任何人，都需要保持对无知保持永远谦卑，对心目中的神圣保持该有的敬畏</li><li>生命,特别是人的生命,一定是人最需要敬畏的内容之一</li><li>外界太大，人太渺小。外界对人而言，永远超越人的认知可及的范围。</li><li>人的无知部分,必然神秘;知道无知,才会谦卑</li><li>如果一个人觉得自己是万能的，一定是狂徒;如果一个人对什么都不珍惜、不敬畏，只会是恶魔</li><li>无知者无畏，无耻者无敌;但无知最大的死敌，一定就是无知的本身，这就是循环的神秘所在。</li></ul><h2 id="医疗职业的三大敌手"><a href="#医疗职业的三大敌手" class="headerlink" title="医疗职业的三大敌手"></a>医疗职业的三大敌手</h2><ul><li>傲慢、冷漠、贪婪</li><li>战胜这三大敌人的过程,就成为良医的过程。</li><li>战胜”傲慢”靠不断学习,知识越多越谦卑,知识不够才傲慢</li><li>战胜“冷漠”,靠心底的善良，利他才能利己，有爱才有信任，有信任才不冷漠</li><li>战胜“贪婪”靠有荣誉感。希望别人正确评价自己，靠积极向上来约束自己，做一个令人尊敬的人。</li></ul><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变成废物的原因</title>
    <link href="/2022/05/14/%E5%8F%98%E6%88%90%E5%BA%9F%E7%89%A9%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <url>/2022/05/14/%E5%8F%98%E6%88%90%E5%BA%9F%E7%89%A9%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<p>对了一下，七条全占了！</p><img src="/2022/05/14/%E5%8F%98%E6%88%90%E5%BA%9F%E7%89%A9%E7%9A%84%E5%8E%9F%E5%9B%A0/5733fd0f53b1403eb762a4d8ac26eb68.jpeg" class="" title="5733fd0f53b1403eb762a4d8ac26eb68"><span id="more"></span><h1 id="一直是废物的原因"><a href="#一直是废物的原因" class="headerlink" title="一直是废物的原因"></a>一直是废物的原因</h1><ol><li>拖延：能拖一天是一天</li><li>犹豫：迟迟不能够下决定</li><li>自我设限：自己怀疑自己</li><li>三分钟热度：失败者都源于半途而废</li><li>总是找借口：安慰自己的懒惰</li><li>逃离现实：不愿意去面对现实</li><li>拒绝学习：这是最可怕的！！</li></ol><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>自省</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2022/05/12/hexo%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/12/hexo%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><strong>hexo 常用命令</strong></p><span id="more"></span><p><a href="https://hexo.io/zh-cn/docs/">hexo 官方文档</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 新建文章</span><br><span class="hljs-attribute">hexo</span> n<br><br><span class="hljs-comment"># 清除缓存</span><br>hexo clean<br><br><span class="hljs-comment"># 生成静态页面+部署</span><br>hexo d -g<span class="hljs-comment"># 等同：hexo g &amp;&amp; hexo d</span><br><span class="hljs-comment"># 生成静态网页</span><br>hexo g<br><span class="hljs-comment"># 部署</span><br>hexo d<br><br><span class="hljs-comment"># 启动服务器预览</span><br>hexo s<br></code></pre></td></tr></table></figure><h2 id="插件卸载与安装"><a href="#插件卸载与安装" class="headerlink" title="插件卸载与安装"></a>插件卸载与安装</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 安装插件</span><br>npm install hexo-xxx-xxx <span class="hljs-comment">--save</span><br><br><span class="hljs-comment"># 卸载插件</span><br>npm uninstall hexo-xxx-xxx <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 新建一个网站</span><br><span class="hljs-variable">$ </span>hexo init [folder]<br></code></pre></td></tr></table></figure><p>如果没有设置<code>folder</code>，Hexo 默认在<strong>当前文件夹</strong>建立网站</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 新建一篇文章,文章名称和标题为 [title],文章采用 [layout] 布局</span><br>$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>会在目录<code>source/_posts</code>下生成 [title].md 文件，[title].md 文件的顶部会使用—分割区域，也称作 Front matter 区<br>如果没有设置 layout 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替（一般默认是 post）。<br>如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># eg</span><br>$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;post title with whitespace&quot;</span><br></code></pre></td></tr></table></figure><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># 生成静态文件<br>$ hexo <span class="hljs-keyword">generate</span><br>$ hexo g<br></code></pre></td></tr></table></figure><p>执行 <code>$ hexo g</code>后会在站点根目录下生成<code>public</code>文件夹, hexo 会将<code>/blog/source/</code>下面的<code>.md</code>后缀的文件编译为<code>.html</code>后缀的文件,存放在<code>/blog/public/</code>路径下</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>启动服务器（常用于调试）</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br>hexo s<br></code></pre></td></tr></table></figure><p>默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82Hexo">http://localhost:4000/。Hexo</a> 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p><table><thead><tr><th align="center">选项</th><th>描述</th><th align="center">eg</th></tr></thead><tbody><tr><td align="center">-p, –port</td><td>重设端口</td><td align="center">hexo s -p 5000</td></tr><tr><td align="center">-s, –static</td><td>只使用静态文件</td><td align="center"></td></tr><tr><td align="center">-l, –log</td><td>启动日记记录，使用覆盖记录格式</td><td align="center"></td></tr><tr><td align="center">-i</td><td>自定义 IP</td><td align="center">hexo s -i 192.168.1.1</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>部署网站,将本地数据部署到远端服务器(如 github、coding)</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-g, –generate</td><td align="center">部署之前预先生成静态文件</td></tr></tbody></table><p>​</p><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">渲染文件<br>hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-o, –output</td><td align="center">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">hexo</span> migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 迁移内容。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>清除缓存,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的 public 文件夹</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></td></tr></table></figure><p>清除缓存文件 <code>(db.json</code>) 和已生成的静态文件 (<code>public)</code>。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">hexo</span> list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>安全模式</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-comment">--safe</span><br></code></pre></td></tr></table></figure><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> --<span class="hljs-literal">debug</span><br></code></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-comment">--silent</span><br></code></pre></td></tr></table></figure><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-comment">--config custom.yml</span><br></code></pre></td></tr></table></figure><p>自定义配置文件的路径，执行后将不再使用 _config.yml。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-comment">--draft</span><br></code></pre></td></tr></table></figure><p>显示 source&#x2F;_drafts 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hexo --cwd <span class="hljs-regexp">/path/</span>to/cwd<br></code></pre></td></tr></table></figure><p>自定义当前工作目录（Current working directory）的路径。</p><p>转自：<a href="https://blog.csdn.net/tian_ci/article/details/93397337">https://blog.csdn.net/tian_ci/article/details/93397337</a></p>]]></content>
    
    
    <categories>
      
      <category>命令汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/05/12/Git/"/>
    <url>/2022/05/12/Git/</url>
    
    <content type="html"><![CDATA[<p><strong>Git命令汇总</strong></p><span id="more"></span><h1 id="Git-命令汇总"><a href="#Git-命令汇总" class="headerlink" title="Git 命令汇总"></a>Git 命令汇总</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>用户名和邮箱代表身份</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>.前有空格，添加所有文件到暂存区</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span>  . <br></code></pre></td></tr></table></figure><p>添加具体文件到暂存区</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> readme.txt <br></code></pre></td></tr></table></figure><p>告诉仓库，文件已经提交到仓库</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;&quot;</span> <br></code></pre></td></tr></table></figure><p>查看是否还有文件未提交</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span> <br></code></pre></td></tr></table></figure><p>恢复文件</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">git <span class="hljs-built_in">restore</span> readme.txt <br></code></pre></td></tr></table></figure><p>可以看到文件的修改内容</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">diff</span> readme.txt <br></code></pre></td></tr></table></figure><p>版本回退</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^     回退到上个版本</span><br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^^    回退到前个版本</span><br>git reser <span class="hljs-comment">--hard HEAD~100  回退到前100个版本</span><br></code></pre></td></tr></table></figure><p>可以查看所有的日志</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git  <span class="hljs-built_in">ref</span>log <br></code></pre></td></tr></table></figure><p> 查到对应的版本号后  eg. 6fcfc89</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard  6fcfc89  </span><br></code></pre></td></tr></table></figure><p><strong>工作区：</strong>就是你在电脑上看到的目录，比如目录下test.git里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。<br><strong>版本库(Repository)：</strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p><h2 id="创建一个新的版本库"><a href="#创建一个新的版本库" class="headerlink" title="创建一个新的版本库"></a>创建一个新的版本库</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">echo</span> <span class="hljs-string">&quot;# test&quot;</span> &gt;&gt; README.md<br><span class="hljs-symbol">git</span> init<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> README.md<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><span class="hljs-symbol">git</span> branch -M main<br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/username/test.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin main<br></code></pre></td></tr></table></figure><h2 id="Push版本库"><a href="#Push版本库" class="headerlink" title="Push版本库"></a>Push版本库</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote add origin https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/username/</span>test.git<br>git branch -M main<br>git push -u origin main<br></code></pre></td></tr></table></figure><p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来,在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了。</p><h2 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h2><p>以上都是用的master分支，下面来创建dev分支，然后切换到dev分支上</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>dev -<span class="hljs-keyword">b </span>表示创建并切换相当于以下两条命令<br>git <span class="hljs-keyword">branch </span>deb<br>git checkout dev<br></code></pre></td></tr></table></figure><p>在dev分支上提交后回到main分支，可以看到main分支上内容没有改变现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 。git merge 命令用于合并指定分支到当前分支上，合并后，再查看可以看到和dev最新提交的是完全一样的。</p><p>总结创建与合并分支命令如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fortran">　　查看分支：git branch<br><br>　　创建分支：git branch <span class="hljs-keyword">name</span><br><br>　　切换分支：git checkout <span class="hljs-keyword">name</span><br><br>　　创建+切换分支：git checkout –b <span class="hljs-keyword">name</span><br><br>　　合并某分支到当前分支：git <span class="hljs-built_in">merge</span> <span class="hljs-keyword">name</span><br><br>　　删除分支：git branch –d <span class="hljs-keyword">name</span><br></code></pre></td></tr></table></figure><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>　　通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。</p><ol><li>创建一个dev分支。</li><li>修改readme.txt内容。</li><li>添加到暂存区。</li><li>切换回主分支(master)。</li><li>合并dev分支，使用命令 git merge –no-ff  -m “注释” dev</li><li>查看历史记录</li></ol><p>git push origin master&#x2F;&#x2F;git push origin dev(次分支不必要同步，可以先合并到主分支再push)</p><ol><li>首先，可以试图用git push origin branch-name推送自己的修改.</li><li>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</li><li>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送</li></ol><p>git提供了一种<strong>强制上传</strong>的方式：git push -f ，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，<strong>因为-f会用本地库覆盖掉远程库</strong>，如果远程库上有重要更新，或者有其他同伴做的修改,也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。</p><h2 id="命令汇总"><a href="#命令汇总" class="headerlink" title="命令汇总"></a>命令汇总</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs maxima">　　<span class="hljs-built_in">mkdir</span>：         XX (创建一个空目录 XX指目录名)<br><br>　　pwd：          显示当前目录的路径。<br><br>　　git init          把当前的目录变成可以管理的git仓库，生成隐藏.git文件。<br><br>　　git add XX       把xx文件添加到暂存区去。<br><br>　　git commit –m “XX”  提交文件 –m 后面的是注释。<br><br>　　git <span class="hljs-built_in">status</span>        查看仓库状态<br><br>　　git <span class="hljs-built_in">diff</span>  XX      查看XX文件修改了那些内容<br><br>　　git <span class="hljs-built_in">log</span>          查看历史记录<br><br>　　git <span class="hljs-built_in">reset</span>  --hard HEAD^ 或者 git <span class="hljs-built_in">reset</span>  --hard HEAD~ 回退到上一个版本<br><br>　　(如果想回退到<span class="hljs-number">100</span>个版本，使用git <span class="hljs-built_in">reset</span> –hard HEAD~<span class="hljs-number">100</span> )<br><br>　　cat XX         查看XX文件内容<br><br>　　git reflog       查看历史记录的版本号id<br><br>　　git checkout -- XX  把XX文件在工作区的修改全部撤销。<br><br>　　git rm XX          删除XX文件<br><br>　　git remote add <span class="hljs-built_in">origin</span> https://github.com/tugenhua0707/testgit 关联一个远程库<br><br>　　git <span class="hljs-built_in">push</span> –u(第一次要用-u 以后不需要) <span class="hljs-built_in">origin</span> master 把当前master分支推送到远程库<br><br>　　git clone https://github.com/tugenhua0707/testgit  从远程库中克隆<br><br>　　git checkout –b dev  创建dev分支 并切换到dev分支上<br><br>　　git branch  查看当前所有的分支<br><br>　　git checkout master 切换回master分支<br><br>　　git merge dev    在当前的分支上合并dev分支<br><br>　　git branch –d dev 删除dev分支<br><br>　　git branch name  创建分支<br><br>　　git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作<br><br>　　git stash list 查看所有被隐藏的文件列表<br><br>　　git stash <span class="hljs-built_in">apply</span> 恢复被隐藏的文件，但是内容不删除<br><br>　　git stash drop 删除文件<br><br>　　git stash <span class="hljs-built_in">pop</span> 恢复文件的同时 也删除文件<br><br>　　git remote 查看远程库的信息<br><br>　　git remote –v 查看远程库的详细信息<br><br>　　git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master  Git会把master分支推送到远程库对应的远程分支上<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>命令汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Audrey Hepburn（奥黛丽·赫本）</title>
    <link href="/2022/05/12/Audrey-Hepburn/"/>
    <url>/2022/05/12/Audrey-Hepburn/</url>
    
    <content type="html"><![CDATA[<p>有人说，上帝亲吻了一个小女孩的脸颊，奥黛丽·赫本就诞生了。</p><img src="/2022/05/12/Audrey-Hepburn/0b6a0750f27d0605dd3a.png" class="" title="世界第一美女奥黛丽·赫本:拥四国血统(堪称时尚标杆) - 强酷窝"><span id="more"></span><h1 id="奥黛丽·赫本：她凭什么是“有史以来最美的女人”"><a href="#奥黛丽·赫本：她凭什么是“有史以来最美的女人”" class="headerlink" title="奥黛丽·赫本：她凭什么是“有史以来最美的女人”"></a>奥黛丽·赫本：她凭什么是“有史以来最美的女人”</h1><p>「来源: ｜视野杂志 ID：shiyezazhi」</p><img src="/2022/05/12/Audrey-Hepburn/c2cec3fdfc0392451ca75530e67985cb7c1e25f1.jpeg" class="" title="img"><p>奥黛丽·赫本是谁？</p><p>有人说，上帝亲吻了一个小女孩的脸颊，奥黛丽·赫本就诞生了。</p><p>的确，很多人第一次知道赫本，都是因为她那张令人过目不忘的脸，优雅且美丽。</p><p>但赫本说，“女人的美丽不在于外表，真正的美丽折射于一个女人的灵魂深处。”</p><img src="/2022/05/12/Audrey-Hepburn/42166d224f4a20a4e63b1ee1f2bfb92b730ed0e1-16523664880006.jpeg" class="" title="img"><p>她不仅是伟大的女演员，是纪梵希的灵感缪斯，是联合国儿童基金会的亲善大使，她也是一个渴望爱与被爱的普通女人，是优雅的化身。</p><p>翻阅她的人生，就像打开一部女性在激荡时代大潮中的灵魂成长书。</p><p>从美开始，却不止于美。</p><p>给人指引，也给人力量。</p><p>总有人问，为何我们都在怀念奥黛丽·赫本？</p><p>其实她的人生就是最好的答案——我们深深感怀的，不只是清丽的容颜与事业的辉煌，还有举世称叹的优雅，善良，才华和修养。</p><img src="/2022/05/12/Audrey-Hepburn/810a19d8bc3eb1353ac1a1c7c7f389dafc1f44b9.jpeg" class="" title="img"><p>赫本出身高贵，但成长并非一帆风顺。</p><p>她的母亲埃拉是荷兰皇室后裔，真正的蓝血贵族，奉行维多利亚式的教养理念，也重视品格与意志的锻造。</p><p>在赫本的童年时期，母亲经常会带她去看画展，听歌剧，感受艺术的熏陶。母亲想在她身上延续一颗贵族的灵魂，但过度的严苛也让她从小缺失了母爱的温柔。</p><p>母亲让赫本必须时刻注意自己的言行，一切按照淑女的标准。年仅7岁，她就被母亲送到千里之外的寄宿学校去学习芭蕾，锻炼独立的人格和坚强的品质。</p><img src="/2022/05/12/Audrey-Hepburn/1ad5ad6eddc451da52bc45f6de10736fd116325f.jpeg" class="" title="img"><p>赫本的父亲罗斯顿在银行工作，却是个不负责任的荡子，而且还有右倾的政治意向，以至于在女儿6岁的时候，就离家出走，一去不返。</p><p>父亲的离去让童年的赫本感觉天塌了一半，也带给了赫本一生的伤痛，从而影响了她多年后的感情倾向，她渴望被爱，同样渴望爱别人。</p><p>好在还有芭蕾。做一名首席芭蕾舞演员，是赫本人生中最初的梦想和精神支柱，日复一日的勤学苦练则磨炼了她的意志，让她有力量第一次走出心灵的沼泽。</p><img src="/2022/05/12/Audrey-Hepburn/a1ec08fa513d2697e586d7673e1693f24216d8ae-16523664962159.jpeg" class="" title="img"><p>青春本是一个人生命中最值得追忆的芳华。然而，赫本的青春却是在战火、杀戮、饥饿、被困中度过的，是一段噩梦般的岁月。</p><p>二战爆发后，荷兰沦陷，赫本母亲整个家族一夜之间一无所有。</p><p>身处炮火之中，目睹亲人被捕，被杀害，每天醒来，都是劫后余生。</p><p>学习条件和生活环境一样恶劣，冬天没有暖气，赫本练习舞蹈时脚部经常被冻伤，但她一直在坚持。</p><p>而且，凭借自身的智慧和被苦难催生的强大意志力，她成为了抗战组织的小小情报员，独自进入山区为盟军送情报，和同学在黑屋子里表演募捐节目，为抗战竭尽所能。</p><p>但德军的镇压越来越残酷，食物已极度匮乏。仅仅活下去，就已经是举步维艰。最艰难的时候，一家人躲在地下室，只能用郁金香球茎充饥。</p><img src="/2022/05/12/Audrey-Hepburn/a686c9177f3e67096b13e20f532abe34f9dc5521.jpeg" class="" title="img"><p>历经五年的黑暗时光，赫本终于等到了一生中最好的生日礼物——和平。</p><p>当盟军到来的时候，一位好心的士兵给了她五条巧克力，饥饿的赫本一口气把它们全吃了进去。没想到，却因此大病了一场。</p><p>实际上，战争对赫本身体的损害远比想象的更严重，比如极度营养不良导致的肠胃病，导致她一生都是身体瘦削，还让她错过了练习芭蕾的最佳年龄。</p><p>战争偷走了赫本的舞蹈梦想，让她再次痛不欲生。</p><p>不过，少女的精神却因战火的淬炼而愈发坚韧。所以，她懂得及时放下，并在痛苦中培植出了“重建人生”的能力，不畏艰辛，重头再来。</p><img src="/2022/05/12/Audrey-Hepburn/38dbb6fd5266d016b3eb0a60f6c6f50e37fa35fa.jpeg" class="" title="img"><p>战后，赫本与母亲一起来到伦敦，开始新的逐梦之旅。</p><p>一开始，尽管只是在舞台剧里担任群演，或者是在电影里跑龙套，但她每一次都会全力以赴，从未有过任何的敷衍与懈怠。</p><p>她深深明白，世间没有从天而降的幸运，如果有，也不过是努力的另一个名字。</p><p>只有通过自身的努力，等待破茧成蝶的契机，才有可能让命运之轮为自己开启。</p><img src="/2022/05/12/Audrey-Hepburn/77c6a7efce1b9d161fb28599923395868e5464c3.jpeg" class="" title="img"><p>选择决定人生，差若毫厘，则失之千里。</p><p>而赫本说，只要机会来了，她就会牢牢抓住。所以当百老汇的橄榄枝伸来时，她毫不犹豫地选择了通往美国的冒险之路。</p><p>彼时，初出茅庐的赫本正在蔚蓝海岸拍戏，她清新灵动的气质打动了法国作家科莱特。科莱特随即邀请她出演自己的音乐剧《琪琪》，并预言她会成为家喻户晓的明星。</p><p>科莱特夫人的预言很快就应验了。《琪琪》的成功，不仅让赫本成为了百老汇的可爱精灵，更间接将她推向了好莱坞的璀璨星途。</p><img src="/2022/05/12/Audrey-Hepburn/34fae6cd7b899e51ddd49e3f234af83ac9950dbd.jpeg" class="" title="img"><p>在电影《罗马假日》中，赫本因饰演安妮公主一角而获得奥斯卡金像奖，继而成为好莱坞最耀眼的新星。</p><p>赫本登上了美国《时代周刊》的封面，人们也突然发现，原来世间有一种美，叫奥黛丽·赫本。</p><p>那是一种与玛丽莲·梦露式的性感截然不同的优雅之美。她从不为取悦观众而垫高胸部，也从不穿纤细的高跟鞋展示惹火的身姿，她仅仅用一件简单的白衬衣就俘获了全世界的心动。</p><img src="/2022/05/12/Audrey-Hepburn/7e3e6709c93d70cf08179d879131f009b8a12b44.jpeg" class="" title="img"><p>而接下来，随着与纪梵希的相遇，她又找到了最合适自己的时尚，在美的领域持续探索，继而把自己的优势变成专属魅力，变成不可复制的赫本式风格。</p><p>她一步一步向前走着，清醒而坚定。</p><p>只是当她蓦然回首时，才发现那个她最想与之分享的人，却没能站在她的身后。</p><p>赫本的未婚夫汉森是个富二代，他们之间曾有过一段非常美好的时光。</p><p>但随着赫本事业的发展，两个人之间聚少离多，当爱情和事业成为单选题时，赫本理性地选择了后者。</p><img src="/2022/05/12/Audrey-Hepburn/5fdf8db1cb1349548f294b5735a3b351d0094ac0.jpeg" class="" title="img"><p>赫本的第一任丈夫是好莱坞演员梅尔·费勒。梅尔比赫本大12岁，高大英俊，成熟稳重，但显然，与妻子的明星光环相比，他的事业一直在走下坡路，这也为他们的婚姻埋下了隐忧。</p><p>对于赫本来说，无论外界怎样看待她与梅尔的感情，她对梅尔都会保持信任与爱。童年时父爱的缺失，让她有了一个根深蒂固的择偶标准，那就是她喜欢能为她带来安全感，具有勇士精神的男性。</p><p>而婚后的赫本，在银幕上的光芒却愈发耀眼。</p><p>如果说《罗马假日》让观众对赫本的美丽一见钟情，那么《甜姐儿》与《修女传》就是真正触及她灵魂的作品，让她蜕变成了“伟大的女演员”，迎来了事业的巅峰。</p><img src="/2022/05/12/Audrey-Hepburn/0eb30f2442a7d933b5b432cdc5a6f01a72f00162.jpeg" class="" title="img"><p>《蒂凡尼的早餐》则是她产后复工的惊世之作，她也向世人证明，奥黛丽·赫本也可以成为银幕上的多面女郎，风情万种，各不相同。</p><p>而真正的优雅，也不是软弱，而是拥有大海一般的内涵和韧性，可以坚强如刚，对抗外界的尖锐，也可以温柔如水，包容生活中的不如意。</p><p>每个走进婚姻的人都相信一个爱情童话：“王子和公主从此过上了幸福的生活。”</p><p>然而现实总是不够完满，生而为人，最难就是求仁得仁。</p><p>随着时间的推移，赫本与梅尔的婚姻同样陷入了困境，她为之努力，却依然徒劳。</p><p>生活如棋局，不仅需要落子无悔的魄力，更需要重建河山的勇气。她告诉自己，不如珍惜所拥有的，放手已失去的，然后擦干眼泪，挺起胸膛，微笑面对即将到来的。</p><img src="/2022/05/12/Audrey-Hepburn/b3fb43166d224f4a59c27bd76b1ab15b9a22d195.jpeg" class="" title="img"><p>赫本的第二任丈夫多蒂是个意大利伯爵，也是一名心理医生，并执教于罗马大学。他们相逢在希腊的岛上，而他告诉她，他其实已经爱了她十六年。</p><p>十六年前，她是银幕上的安妮公主，美人如花隔云端，他是情窦初开的少年，只能仰望她的光环，珍藏她的海报，把她当成心底最柔软的秘密。</p><p>恋爱后，他很快在罗马向她求婚：“亲爱的公主，这个梦我做了16年，现在终于要实现了。”</p><img src="/2022/05/12/Audrey-Hepburn/1b4c510fd9f9d72a6344ee5bb4c7093d359bbb4e.jpeg" class="" title="img"><p>她感动得要落下眼泪。想起曾经出演的《罗马假日》，好像安妮公主再回罗马，终为爱情圆梦。</p><p>赫本婚后在罗马生活了十年，无论是名扬四海，还是回归家庭，她依然是时尚的宠儿，是优雅的代言人。她一直奉行着自己的时尚哲学，删繁就简，回归本真，一如她的人生哲学，越简单，越美好。</p><p>只是她的第二段婚姻还是以分手告终。因为她再多的包容与美好也不能改变丈夫的风流成性。</p><img src="/2022/05/12/Audrey-Hepburn/b58f8c5494eef01f679a99898313b82cbe317de2.jpeg" class="" title="img"><p>好在历经沧桑，屡次被爱所伤之后，她终于遇到了真正的灵魂伴侣罗伯特。</p><p>他们一见如故，精神契合，那时，连一纸婚书都是多余。在爱人的呵护下，晚年的赫本容光焕发，心里就想住了一个小女孩。</p><p>“有多少人爱过你的美貌，以虚伪或真情，惟独一人曾爱你那朝圣者的心，爱你脸上岁月的留痕。”叶芝的诗歌，正好可以为她生命中最后一段恋情做注脚。</p><img src="/2022/05/12/Audrey-Hepburn/4034970a304e251f13f27908cf6be81e7e3e532b.jpeg" class="" title="img"><p>赫本有一句名言：“随着岁月增长，你会发现，你有两只手，一只帮助自己，一只帮助他人。”</p><p>在罗伯特的支持下，她成为了联合国儿童基金会的爱心大使，将余生所有的精力都奉献给了这份工作，包括捐献所有的片酬。</p><p>在一次专访中，有记者质疑赫本为自己的名气炒作，她理直气壮地说：“你觉得奥黛丽·赫本需要炒作名气吗？为了孩子们，我愿意为他们摘月亮。”</p><p>如她所言，在担任爱心大使的几年时间里，她和罗伯特一共走访了几十个国家，风雨无阻，历经万难。他们甚至去了索马里。去办理签证的时候，工作人员不无担心地说，“要到达索马里，你得保证自己的飞机不会被击落。”</p><img src="/2022/05/12/Audrey-Hepburn/ac345982b2b7d0a219c0e0c9a20257004a369a4b.jpeg" class="" title="img"><p>当时的索马里一如人间地狱，赫本每天都在哭泣。她抱着那些骨瘦如柴的孩子们，喂他们进食，给他们温暖和善意。她为那些小小的尸体祷告，祈求上帝能够将他们带往天堂。</p><p>最后，因为长期劳累，她病倒了。她的阑尾发生了癌变，而医生推测，她应该在五年前就已经患上了癌症。原来她一直在带病工作。</p><p>赫本临终时，儿子问她：“您有什么遗憾吗？”</p><p>她说：“我没有遗憾，我只是不明白为什么有那么多孩子在受苦。”</p><p>赫本去世后，美国前总统里根致悼词说：“奥黛丽·赫本是一位真正伟大的女性，人们将会十分想念她。”</p><p>老牌影星伊丽莎白·泰勒说道：“我们的天使回天国了，如今上帝有了一位最美丽的天使。”</p><p>《纽约时报》则称：“纵然岁月的痕迹爬上她的额头，眼角布满鱼尾纹，下巴的弧线也变得模糊，人们想到奥黛丽·赫本，仍会为之动容，为之微笑，为之怀念。”</p><img src="/2022/05/12/Audrey-Hepburn/3801213fb80e7bec98c504244fc3983199506bca.jpeg" class="" title="img"><p>魅力的双唇，源于亲切友善的语言。</p><p>可爱的双眼，源于善于捕捉别人的优点。</p><p>苗条的身材，源于乐意将食物与饥饿的人分享。</p><p>美丽的秀发，源于每天有孩子的手指穿过它。</p><p>优雅的姿态，源于习惯与知识同行。</p><p>人若要成为真正意义上的人，必须充满精力，自我反省，自我更新，自我成长，而不要向他人抱怨。</p><p>请记得，如果你需要帮助，请从现在起善用你的双手。</p><p>随着岁月增长，你会发现，你有两只手，一只帮助自己，一只帮助他人。</p><p>赫本的这首《永葆美丽的秘诀》，一如她的人生写照，爱的根须，慢慢在时间里结出果实——坚韧的品格，智慧的头脑，源自内心的善良，一辈子的优雅……她全都一字不漏地做到了。</p><img src="/2022/05/12/Audrey-Hepburn/4d086e061d950a7b49072882683c43d0f3d3c9b8.jpeg" class="" title="img"><p>人们称她为“人间的天使”，也不是因为她有美丽的容颜，而是因为她有一颗珍珠般不被时间磨损，不被苦难打倒，不受名利羁绊的美好灵魂。</p><p>如果说美是上天的恩赐，那么爱就是她一生的宗教。</p><p>生于动荡的时代，破碎的家庭中，长在战乱年代，贫瘠的日子里。年少时离乡背井，独自闯荡光怪陆离的好莱坞，在明星如云中找到自己的独特定位。</p><p>一生追求家庭的温暖，却被情伤得最深；镁光灯给了她事业和财务自由，但也无时无刻不被谣言包围，被声名所困。</p><img src="/2022/05/12/Audrey-Hepburn/4e4a20a4462309f7640727bf1ae32dfad6cad62e.jpeg" class="" title="img"><p>然而，就是这样的她，能够在功成名就的时刻看淡名利，在事业鼎盛时远离好莱坞繁华的诱惑，一生坚持真诚和自我。即使不断被爱所伤，却永远相信爱情。</p><p>尽管年少便缺乏温暖，却尽力温暖了更多的人；尽管功成名就，却身赴险境，用天使之爱去修补这残缺的世界。</p><p>她就是奥黛丽·赫本。她的故事讲完了，但她的美丽与优雅，却依旧深深触动着我们的内心，也将被我们代代传颂，如星辰一般永恒。</p><p>本文内容来源于艾略新书《奥黛丽·赫本：一辈子活在优雅里》（90周年珍藏纪念版）</p><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>人物</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/06/hello-world/"/>
    <url>/2022/05/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>hello</category>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
