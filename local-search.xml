<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Labelme格式转COCO</title>
    <link href="/2023/04/04/Labelme%E6%A0%BC%E5%BC%8F%E8%BD%ACCOCO/"/>
    <url>/2023/04/04/Labelme%E6%A0%BC%E5%BC%8F%E8%BD%ACCOCO/</url>
    
    <content type="html"><![CDATA[<p>在跑 Mask RCNN 项目时需要将 labelme 格式转成 coco 格式后进行训练，本文记录了这个过程以及使用的代码以便日后查用和回顾。</p><span id="more"></span><h1 id="Labelme-格式转-COCO"><a href="#Labelme-格式转-COCO" class="headerlink" title="Labelme 格式转 COCO"></a>Labelme 格式转 COCO</h1><p>需要注意将代码中的 bmp 改成你的图片的对应格式</p><p>1.使用 Labelme 标注图片</p><p>​ 我的 labelme 的版本为“labelme 5.1.1”（安装参考<a href="https://blog.csdn.net/weixin_43582443/article/details/111747112%EF%BC%89%EF%BC%8C%E5%9C%A8%E8%AF%A5%E7%89%88%E6%9C%AC%E4%B8%8B%EF%BC%8C%E9%80%89%E6%8B%A9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BB%98%E5%88%B6%EF%BC%8C%E7%BB%98%E5%88%B6%E5%A5%BDROI%E5%90%8E%E5%8F%AF%E4%BB%A5%E7%82%B9%E5%87%BBSAVE%E5%B0%86%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%82![image-20230403191406839](./Labelme%E6%A0%BC%E5%BC%8F%E8%BD%ACCOCO/image-20230403191406839.png)">https://blog.csdn.net/weixin_43582443/article/details/111747112），在该版本下，选择多边形绘制，绘制好ROI后可以点击SAVE将文件保存到对应的文件夹。![image-20230403191406839](./Labelme%E6%A0%BC%E5%BC%8F%E8%BD%ACCOCO/image-20230403191406839.png)</a></p><p>2.创建 COCO 格式文件夹</p><p>​ 创建 images 和 labelme 文件夹，文件夹下分别创建 test2023、total2023、train2023、val2023 四个文件夹,文件树如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">├─images<br>│  ├─test2023<br>│  ├─total2023<br>│  ├─train2023<br>│  └─val2023<br>└─labelme<br>    ├─test2023<br>    ├─total2023<br>    ├─train2023<br>    └─val2023<br></code></pre></td></tr></table></figure><p>​ 完成这一步之后，将标注过的图片文件存入 images&#x2F;total2023,将以.json 为结尾的标注文件存入 labelme&#x2F;total2023。</p><p>3.根据标注文件创建 txt</p><p>​ 在与 images 同级的文件夹下创建 create_txt.py 文件，该文件的代码如下。运行该文件之后，会在当前文件夹下生成 trainval2023.txt、test2023.txt、train2023.txt、val2023.txt 四个文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> random<br><br>trainval_percent =<span class="hljs-number">0.8</span>  <span class="hljs-comment"># 验证集+训练集占总比例多少</span><br>train_percent = <span class="hljs-number">0.7</span> <span class="hljs-comment"># 训练数据集占验证集+训练集比例多少</span><br>jsonfilepath =  <span class="hljs-string">&#x27;labelme/total2023&#x27;</span><br>txtsavepath = <span class="hljs-string">&#x27;./&#x27;</span><br>total_xml = os.listdir(jsonfilepath)<br><br>num = <span class="hljs-built_in">len</span>(total_xml)<br><span class="hljs-built_in">list</span> = <span class="hljs-built_in">range</span>(num)<br>tv = <span class="hljs-built_in">int</span>(num * trainval_percent)<br>tr = <span class="hljs-built_in">int</span>(tv * train_percent)<br>trainval = random.sample(<span class="hljs-built_in">list</span>, tv)<br>train = random.sample(trainval, tr)<br><br>ftrainval = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./trainval2023.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)  <span class="hljs-comment"># 验证集和训练集</span><br>ftest = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./test2023.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>ftrain = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./train2023.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>fval = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./val2023.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>:<br>    name = total_xml[i][:-<span class="hljs-number">5</span>] + <span class="hljs-string">&#x27;\n&#x27;</span><br>    <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> trainval:<br>        ftrainval.write(name)<br>        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> train:<br>            ftrain.write(name)<br>        <span class="hljs-keyword">else</span>:<br>            fval.write(name)<br>    <span class="hljs-keyword">else</span>:<br>        ftest.write(name)<br><br>ftrainval.close()<br>ftrain.close()<br>fval.close()<br>ftest.close()<br></code></pre></td></tr></table></figure><p>4.将标注文件和图片文件分配到各个文件夹中</p><p>​ 运行 classify.py 文件，按照 3 生成的 txt 文件中的信息将两个 total2023 文件夹中标注文件和图片文件分别分配到 test2023、train2023、val2023 共六个文件夹中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv<br><br>sets=[<span class="hljs-string">&#x27;train2023&#x27;</span>,  <span class="hljs-string">&#x27;val2023&#x27;</span>, <span class="hljs-string">&#x27;test2023&#x27;</span>]<br><span class="hljs-keyword">for</span> image_set <span class="hljs-keyword">in</span> sets:<br>    image_ids = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./%s.txt&#x27;</span>%(image_set)).read().strip().split()<br>    <span class="hljs-keyword">for</span> image_id <span class="hljs-keyword">in</span> image_ids:<br>        img = cv.imread(<span class="hljs-string">&#x27;images/total2023/%s.bmp&#x27;</span> % (image_id))<br>        json=<span class="hljs-string">&#x27;labelme/total2023/%s.json&#x27;</span>% (image_id)<br>        cv.imwrite(<span class="hljs-string">&#x27;images/%s/%s.bmp&#x27;</span> % (image_set,image_id), img)<br>        cv.imwrite(<span class="hljs-string">&#x27;labelme/%s/%s.bmp&#x27;</span> % (image_set,image_id), img)<br>        shutil.copy(json,<span class="hljs-string">&#x27;labelme/%s/%s.json&#x27;</span> % (image_set,image_id))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;finished&quot;</span>)<br></code></pre></td></tr></table></figure><p>​ 5.生成 coco 格式的文件</p><p>​ 在当前文件夹下创建 annotations 文件夹和 labels.txt、labelme2coco.py 文件。annotations 文件夹为空，label.txt 与 labelme2coco.py 内容如下。</p><p>labels.txt 存储标注文件时的类,我标注的文件一共有两类，分别为 scale 与 descale，文件内容如下，当类不同的时候修改其中的类文件，每个类换行。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-built_in">_</span><span class="hljs-built_in">_</span>ignore<span class="hljs-built_in">_</span><span class="hljs-built_in">_</span><br><span class="hljs-built_in">_</span><span class="hljs-built_in">_</span>background<span class="hljs-built_in">_</span><span class="hljs-built_in">_</span><br>scale<br>descale<br></code></pre></td></tr></table></figure><p>对于 train2023、test2023、val2023 文件夹，修改 labelme2coco.py 中的 input 和 output，一共运行三次，每次会在 annotations 文件夹里生成一个对应的 COCO 格式的文件夹。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><br><span class="hljs-keyword">import</span> argparse<br><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> os.path <span class="hljs-keyword">as</span> osp<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> uuid<br><br><span class="hljs-keyword">import</span> imgviz<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">import</span> labelme<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">import</span> pycocotools.mask<br><span class="hljs-keyword">except</span> ImportError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Please install pycocotools:\n\n    pip install pycocotools\n&quot;</span>)<br>    sys.exit(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># parser = argparse.ArgumentParser(</span><br>    <span class="hljs-comment">#    formatter_class=argparse.ArgumentDefaultsHelpFormatter</span><br>    <span class="hljs-comment"># )</span><br>    <span class="hljs-comment"># parser.add_argument(&quot;input_dir&quot;, help=&quot;input annotated directory&quot;)</span><br>    <span class="hljs-comment"># parser.add_argument(&quot;output_dir&quot;, help=&quot;output dataset directory&quot;)</span><br>    <span class="hljs-comment"># parser.add_argument(&quot;--labels&quot;, help=&quot;labels file&quot;, required=True)</span><br>    <span class="hljs-comment"># parser.add_argument(</span><br>    <span class="hljs-comment">#    &quot;--noviz&quot;, help=&quot;no visualization&quot;, action=&quot;store_true&quot;</span><br>    <span class="hljs-comment"># )</span><br>    <span class="hljs-comment"># args = parser.parse_args()</span><br><br>    input_dir = <span class="hljs-string">&#x27;./labelme/train2023/&#x27;</span><br>    output_dir = <span class="hljs-string">&#x27;./annotations/train2023/&#x27;</span><br>    labels = <span class="hljs-string">&#x27;labels.txt&#x27;</span><br>    noviz = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">if</span> osp.exists(output_dir):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output directory already exists:&quot;</span>, output_dir)<br>        sys.exit(<span class="hljs-number">1</span>)<br>    os.makedirs(output_dir)<br>    os.makedirs(osp.join(output_dir, <span class="hljs-string">&quot;JPEGImages&quot;</span>))<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> noviz:<br>        os.makedirs(osp.join(output_dir, <span class="hljs-string">&quot;Visualization&quot;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Creating dataset:&quot;</span>, output_dir)<br><br>    now = datetime.datetime.now()<br><br>    data = <span class="hljs-built_in">dict</span>(<br>        info=<span class="hljs-built_in">dict</span>(<br>            description=<span class="hljs-literal">None</span>,<br>            url=<span class="hljs-literal">None</span>,<br>            version=<span class="hljs-literal">None</span>,<br>            year=now.year,<br>            contributor=<span class="hljs-literal">None</span>,<br>            date_created=now.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>),<br>        ),<br>        licenses=[<span class="hljs-built_in">dict</span>(url=<span class="hljs-literal">None</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">0</span>, name=<span class="hljs-literal">None</span>,)],<br>        images=[<br>            <span class="hljs-comment"># license, url, file_name, height, width, date_captured, id</span><br>        ],<br>        <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;instances&quot;</span>,<br>        annotations=[<br>            <span class="hljs-comment"># segmentation, area, iscrowd, image_id, bbox, category_id, id</span><br>        ],<br>        categories=[<br>            <span class="hljs-comment"># supercategory, id, name</span><br>        ],<br>    )<br><br>    class_name_to_id = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">open</span>(labels).readlines()):<br>        class_id = i - <span class="hljs-number">1</span>  <span class="hljs-comment"># starts with -1</span><br>        class_name = line.strip()<br>        <span class="hljs-keyword">if</span> class_id == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">assert</span> class_name == <span class="hljs-string">&quot;__ignore__&quot;</span><br>            <span class="hljs-keyword">continue</span><br>        class_name_to_id[class_name] = class_id<br>        data[<span class="hljs-string">&quot;categories&quot;</span>].append(<br>            <span class="hljs-built_in">dict</span>(supercategory=<span class="hljs-literal">None</span>, <span class="hljs-built_in">id</span>=class_id, name=class_name,)<br>        )<br><br>    out_ann_file = osp.join(output_dir, <span class="hljs-string">&quot;annotations.json&quot;</span>)<br>    label_files = glob.glob(osp.join(input_dir, <span class="hljs-string">&quot;*.json&quot;</span>))<br>    <span class="hljs-keyword">for</span> image_id, filename <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(label_files):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generating dataset from:&quot;</span>, filename)<br><br>        label_file = labelme.LabelFile(filename=filename)<br><br>        base = osp.splitext(osp.basename(filename))[<span class="hljs-number">0</span>]<br>        out_img_file = osp.join(output_dir, <span class="hljs-string">&quot;JPEGImages&quot;</span>, base + <span class="hljs-string">&quot;.bmp&quot;</span>)<br><br>        img = labelme.utils.img_data_to_arr(label_file.imageData)<br>        imgviz.io.imsave(out_img_file, img)<br>        data[<span class="hljs-string">&quot;images&quot;</span>].append(<br>            <span class="hljs-built_in">dict</span>(<br>                license=<span class="hljs-number">0</span>,<br>                url=<span class="hljs-literal">None</span>,<br>                <span class="hljs-comment"># file_name=osp.relpath(out_img_file, osp.dirname(out_ann_file)),</span><br>                file_name=base + <span class="hljs-string">&quot;.bmp&quot;</span>,<br>                height=img.shape[<span class="hljs-number">0</span>],<br>                width=img.shape[<span class="hljs-number">1</span>],<br>                date_captured=<span class="hljs-literal">None</span>,<br>                <span class="hljs-built_in">id</span>=image_id,<br>            )<br>        )<br><br>        masks = &#123;&#125;  <span class="hljs-comment"># for area</span><br>        segmentations = collections.defaultdict(<span class="hljs-built_in">list</span>)  <span class="hljs-comment"># for segmentation</span><br>        <span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> label_file.shapes:<br>            points = shape[<span class="hljs-string">&quot;points&quot;</span>]<br>            label = shape[<span class="hljs-string">&quot;label&quot;</span>]<br>            group_id = shape.get(<span class="hljs-string">&quot;group_id&quot;</span>)<br>            shape_type = shape.get(<span class="hljs-string">&quot;shape_type&quot;</span>, <span class="hljs-string">&quot;polygon&quot;</span>)<br>            mask = labelme.utils.shape_to_mask(<br>                img.shape[:<span class="hljs-number">2</span>], points, shape_type<br>            )<br><br>            <span class="hljs-keyword">if</span> group_id <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                group_id = uuid.uuid1()<br><br>            instance = (label, group_id)<br><br>            <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">in</span> masks:<br>                masks[instance] = masks[instance] | mask<br>            <span class="hljs-keyword">else</span>:<br>                masks[instance] = mask<br><br>            <span class="hljs-keyword">if</span> shape_type == <span class="hljs-string">&quot;rectangle&quot;</span>:<br>                (x1, y1), (x2, y2) = points<br>                x1, x2 = <span class="hljs-built_in">sorted</span>([x1, x2])<br>                y1, y2 = <span class="hljs-built_in">sorted</span>([y1, y2])<br>                points = [x1, y1, x2, y1, x2, y2, x1, y2]<br>            <span class="hljs-keyword">if</span> shape_type == <span class="hljs-string">&quot;circle&quot;</span>:<br>                (x1, y1), (x2, y2) = points<br>                r = np.linalg.norm([x2 - x1, y2 - y1])<br>                <span class="hljs-comment"># r(1-cos(a/2))&lt;x, a=2*pi/N =&gt; N&gt;pi/arccos(1-x/r)</span><br>                <span class="hljs-comment"># x: tolerance of the gap between the arc and the line segment</span><br>                n_points_circle = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">int</span>(np.pi / np.arccos(<span class="hljs-number">1</span> - <span class="hljs-number">1</span> / r)), <span class="hljs-number">12</span>)<br>                i = np.arange(n_points_circle)<br>                x = x1 + r * np.sin(<span class="hljs-number">2</span> * np.pi / n_points_circle * i)<br>                y = y1 + r * np.cos(<span class="hljs-number">2</span> * np.pi / n_points_circle * i)<br>                points = np.stack((x, y), axis=<span class="hljs-number">1</span>).flatten().tolist()<br>            <span class="hljs-keyword">else</span>:<br>                points = np.asarray(points).flatten().tolist()<br><br>            segmentations[instance].append(points)<br>        segmentations = <span class="hljs-built_in">dict</span>(segmentations)<br><br>        <span class="hljs-keyword">for</span> instance, mask <span class="hljs-keyword">in</span> masks.items():<br>            cls_name, group_id = instance<br>            <span class="hljs-keyword">if</span> cls_name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> class_name_to_id:<br>                <span class="hljs-keyword">continue</span><br>            cls_id = class_name_to_id[cls_name]<br><br>            mask = np.asfortranarray(mask.astype(np.uint8))<br>            mask = pycocotools.mask.encode(mask)<br>            area = <span class="hljs-built_in">float</span>(pycocotools.mask.area(mask))<br>            bbox = pycocotools.mask.toBbox(mask).flatten().tolist()<br><br>            data[<span class="hljs-string">&quot;annotations&quot;</span>].append(<br>                <span class="hljs-built_in">dict</span>(<br>                    <span class="hljs-built_in">id</span>=<span class="hljs-built_in">len</span>(data[<span class="hljs-string">&quot;annotations&quot;</span>]),<br>                    image_id=image_id,<br>                    category_id=cls_id,<br>                    segmentation=segmentations[instance],<br>                    area=area,<br>                    bbox=bbox,<br>                    iscrowd=<span class="hljs-number">0</span>,<br>                )<br>            )<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> noviz:<br>            viz = img<br>            <span class="hljs-keyword">if</span> masks:<br><br>                listdata_labels = []<br>                listdata_captions = []<br>                listdata_masks = []<br><br>                <span class="hljs-keyword">for</span> (cnm, gid), msk <span class="hljs-keyword">in</span> masks.items():<br>                    <span class="hljs-keyword">if</span> cnm <span class="hljs-keyword">in</span> class_name_to_id:<br>                        listdata_labels.append(class_name_to_id[cnm])<br>                        listdata_captions.append(cnm)<br>                        listdata_masks.append(msk)<br><br>                listdata = <span class="hljs-built_in">zip</span>(listdata_labels,<br>                               listdata_captions, listdata_masks)<br>                labels, captions, masks = <span class="hljs-built_in">zip</span>(*listdata)<br>                <span class="hljs-comment"># labels, captions, masks = zip(*[(listdata_labels, listdata_captions, listdata_masks)])</span><br><br>                <span class="hljs-comment"># print(len(masks))</span><br><br>                <span class="hljs-comment"># labels, captions, masks = zip(</span><br>                <span class="hljs-comment">#    *[</span><br>                <span class="hljs-comment">#        (class_name_to_id[cnm], cnm, msk)</span><br>                <span class="hljs-comment">#        for (cnm, gid), msk in masks.items()</span><br>                <span class="hljs-comment">#        if cnm in class_name_to_id</span><br>                <span class="hljs-comment">#    ]</span><br>                <span class="hljs-comment"># )</span><br>                viz = imgviz.instances2rgb(<br>                    image=img,<br>                    labels=labels,<br>                    masks=masks,<br>                    captions=captions,<br>                    font_size=<span class="hljs-number">15</span>,<br>                    line_width=<span class="hljs-number">2</span>,<br>                )<br>            out_viz_file = osp.join(<br>                output_dir, <span class="hljs-string">&quot;Visualization&quot;</span>, base + <span class="hljs-string">&quot;.bmp&quot;</span><br>            )<br>            imgviz.io.imsave(out_viz_file, viz)<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(out_ann_file, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        json.dump(data, f)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>生成的文件夹格式为</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">├─annotations<br>   └─train2023<br>       ├─JPEGImages<br>       └─Visualization<br></code></pre></td></tr></table></figure><p>程序正常运行时，输出如下</p><p><img src="/./Labelme%E6%A0%BC%E5%BC%8F%E8%BD%ACCOCO/image-20230403194922908-1680522776044-3.png" alt="image-20230403194922908"></p><p>以 train2023 为例，在 annotations 文件夹中也生成了一个 train2023 文件夹，该文件夹下包括 JPEGImages、Visualization 两个文件夹以及 annotations.json 文件，JPEGImages 里存储着原始图片，Visualization 存储着标注后可视化的图片，annotations.json 文件中存储着 coco 格式的标注文件，对应原始的 train2023 中的文件。</p><p>参考：</p><p><a href="https://blog.csdn.net/weixin_43582443/article/details/111747112">Labelme 的安装和打开并使用</a></p><p><a href="https://blog.csdn.net/wangjianwei19911218/article/details/126348135">化学实验室自动化 - 1. 深度学习视觉检测（实例分割） - COCO 格式的化学实验室常见物体实例分割数据集制作</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Keil新建工程项目</title>
    <link href="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>因为做到一个项目需要用到极海APM32F030C8T6芯片（STM32F030C8T6的国产替代），因此记录做项目的过程，以方便复现,本文为新建一个基于标准库的项目模板。</p><span id="more"></span><p>1.从<a href="https://www.geehy.com/apm32?id=35">极海半导体官网</a>，下载pack支持包，双击pack导入支持包</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212102511511.png" class="" title="image-20221212102511511"><p>由于现在的芯片更新迭代速度很快，因此若将所有市面上的芯片对应的代码集合在一个软件，软件就会很庞大且冗余，因此从Keil5开始，以Pack支持包的形式打包每个系列芯片的代码。</p><p>2.在Project下，找到New μVision Project</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221211194820192.png" class="" title="image-20221211194820192"><p>点击New μVision Project新建工程后</p><p>3.从导入的Pack软件包中，选择对应的芯片型号</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212102607320.png" class="" title="image-20221212102607320"><p>4.添加启动文件</p><p>在工程文件夹下新建Start文件夹</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212103853464.png" class="" title="image-20221212103853464"><p>从已有的工程文件夹中复制三个文件到Start</p><p>stm32f0xx.h——描述寄存器配置</p><p>system_stm32f0xx.c和system_stm32f0xx.h——配置时钟、主频等</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212103411401-16708127580861.png" class="" title="image-20221212103411401"><p>从已有的工程文件的arm文件夹中，复制所有启动文件</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212103703923.png" class="" title="image-20221212103703923"><p>相似的方法，在原工程文件夹中找到core_cm0.h文件复制并粘贴到Start文件夹中，这是内核的寄存器描述文件</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212104413047.png" class="" title="image-20221212104413047"><p>将Keil5中的Source Group1文件夹改成Start，并添加文件</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212104113444.png" class="" title="image-20221212104113444"><p>5.添加文件到工程</p><p>右击Start，并添加文件到Start</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212104733389.png" class="" title="image-20221212104733389"><p>根据芯片的型号添加startup_stm32f0xx.s</p><p>并添加其他所有后缀为.c、.h的文件</p><p>6.添加头文件路径</p><p>点击魔术棒</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212105024471.png" class="" title="image-20221212105024471"><p>选择C&#x2F;C++</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212105042463.png" class="" title="image-20221212105042463"><p>点击Include Paths右边的三个点，添加Start文件夹到Include Paths中</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212105133549.png" class="" title="image-20221212105133549"><p>7.添加main文件</p><p>在工程文件夹中新建User文件夹</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212105224082.png" class="" title="image-20221212105224082"><p>在Keil项目中右击Target1，点击Add Group</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212105321185.png" class="" title="image-20221212105321185"><p>并将添加的New Group改名为User</p><p>右击User并添加main文件到User文件夹中</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212105504313.png" class="" title="image-20221212105504313"><p>8.添加库函数</p><p>在项目文件夹下新建Library文件夹</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212111102780.png" class="" title="image-20221212111102780"><p>在原有工程文件的Libraries文件夹下找到inc和src文件夹，并将这两个文件夹中的.c和.h文件全部复制项目的Library文件夹中</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212111237668.png" class="" title="image-20221212111237668"><p>在Keil5工程文件中将所有的库函数都添加</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212111416936.png" class="" title="image-20221212111416936"><p>打开原有的工程项目中的Project文件夹</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212111530836.png" class="" title="image-20221212111530836"><p>conf文件用来配置库函数头文件的包含关系并有用来参数检查的函数定义，两个it文件是用来存放中断函数（interrupt）</p><p>将这三个文件复制下来并粘贴到工程文件夹下的User目录</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212111740915.png" class="" title="image-20221212111740915"><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212111805456.png" class="" title="image-20221212111805456"><p>打开stm32f0xx.h文件</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212111930858.png" class="" title="image-20221212111930858"><p>将USE_STDPERIPH_DRIVER复制到C&#x2F;C++中的预定义中，这样才能包含标准外设库，即库函数</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212111943686.png" class="" title="image-20221212111943686"><p>还需要将User和Library添加到头文件目录中去</p><img src="/2022/12/11/Keil5%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE/image-20221212112139100.png" class="" title="image-20221212112139100"><p>编译并烧录即可</p>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM3203C8T6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23个机器学习最佳入门项目</title>
    <link href="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>【导读】本文为你介绍23种机器学习项目创意，以通过项目学习来提高代码能力。</p><span id="more"></span><p>转载：<a href="https://mp.weixin.qq.com/s/osniD4f4SbeVJjM2XhDM_A">23个机器学习最佳入门项目（附源代码） (qq.com)</a></p><p>本文仅做记录以备以后翻看，非商业用途，侵删。</p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640.jpeg" class="" title="图片"><p>我们都知道，教科书上所学与实际操作还是有出入的，那关于机器学习有什么好的项目可以实操吗？</p><p>我们为你推荐这篇文章，在本教程中，涵盖面向初学者，中级专家和专家的23种机器学习项目创意，以获取有关该增长技术的真实经验。这些机器学习项目构想将帮助你了解在职业生涯中取得成功、和当下就业所需的所有实践。</p><p>通过项目学习是你短期内能做的最好投资，这些项目构想使你能够快速发展和增强机器学习技能。语言上，这些机器学习项目可以用Python，R或任何其他工具开发。</p><p><strong>面向初学者的机器学习项目</strong></p><p>在本部分中，我们列出了针对初学者&#x2F;初学者的顶级机器学习项目，如果你已经从事基础机器学习项目，请跳至下一部分：中级机器学习项目</p><p><strong>1.鸢尾花分类项目</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-16702173124221.png" class="" title="图片"><p>项目构想：鸢尾花有不同的种类，你可以根据花瓣和萼片的长度来区分它们。这是机器学习初学者预测新鸢尾花种类的基础项目。</p><p>数据集：鸢尾花分类数据集 </p><p><a href="https://archive.ics.uci.edu/ml/datasets/Iris">https://archive.ics.uci.edu/ml/datasets/Iris</a></p><p><strong>2. Emojify –使用Python创建自己的表情符号</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-16702173124222.png" class="" title="图片"><p>项目构想：该机器学习项目的目标是对人的面部表情进行分类并将其映射为表情符号。我们将建立一个卷积神经网络来识别面部表情。然后，我们将使用相应的表情符号或头像来映射这些情感。</p><p>源代码：Emojify项目</p><p><a href="https://data-flair.training/blogs/create-emoji-with-deep-learning/">https://data-flair.training/blogs/create-emoji-with-deep-learning/</a> </p><p><strong>3.使用机器学习进行贷款预测</strong></p><p>项目构想：该ML项目背后的构想是建立一个模型，该模型将对用户可以贷款多少进行分类。它基于用户的婚姻状况，教育程度，受抚养人数和就业情况。我们可以为此项目建立一个线性模型。</p><p>数据集：贷款预测数据集 </p><p><a href="https://www.kaggle.com/altruistdelhite04/loan-prediction-problem-dataset">https://www.kaggle.com/altruistdelhite04/loan-prediction-problem-dataset</a></p><p><strong>4.住房价格预测项目</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-16702173124233.png" class="" title="图片"><p>项目构想：数据集包含波士顿剩余区域的房价。房子的费用根据犯罪率，房间数量等各种因素而变化。对于初学者来说，这是一个很好的ML项目，它可以根据新数据预测价格。</p><p>数据集：房屋价格预测数据集 </p><p><a href="https://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html">https://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html</a></p><p><strong>5. MNIST数字分类机器学习项目</strong></p><p>项目构想：MNIST数字分类python项目使机器能够识别手写数字。该项目对于计算机视觉可能非常有用。在这里，我们将使用MNIST数据集使用卷积神经网络训练模型。</p><p>数据集：MNIST数字识别数据集 </p><p><a href="https://drive.google.com/file/d/1hJiOlxctFH3uL2yTqXU_1f6c0zLr8V_K/view">https://drive.google.com/file/d/1hJiOlxctFH3uL2yTqXU_1f6c0zLr8V_K/view</a></p><p>源代码：手写数字识别项目</p><p><a href="https://data-flair.training/blogs/python-deep-learning-project-handwritten-digit-recognition/">https://data-flair.training/blogs/python-deep-learning-project-handwritten-digit-recognition/</a></p><p><strong>6.使用机器学习预测股价</strong></p><p>项目构想：有许多可用于股票市场价格的数据集。这个机器学习初学者的项目旨在根据上一年的数据预测股票市场的未来价格。</p><p>数据集：股票价格预测数据集</p><p><a href="https://www.kaggle.com/c/two-sigma-financial-news/data">https://www.kaggle.com/c/two-sigma-financial-news/data</a></p><p>源代码：股票价格预测项目</p><p><a href="https://data-flair.training/blogs/stock-price-prediction-machine-learning-project-in-python/">https://data-flair.training/blogs/stock-price-prediction-machine-learning-project-in-python/</a></p><p><strong>7.泰坦尼克号生存计划</strong></p><p>项目构想：这将是一个有趣的项目，因为我们将预测某人是否会在泰坦尼克号飞船中幸存下来。对于这个初学者的项目，我们将使用泰坦尼克号数据集，其中包含幸存者和在泰坦尼克号飞船中死亡的人的真实数据。</p><p>数据集：《泰坦尼克号生存》数据集 </p><p><a href="https://www.kaggle.com/c/titanic">https://www.kaggle.com/c/titanic</a></p><p><strong>8.葡萄酒质量检测项目</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-16702173124234.png" class="" title="图片"><p>项目构想：在该项目中，我们可以构建一个界面来预测红酒的质量。它将使用葡萄酒的化学信息，并基于机器学习模型，它将为我们提供葡萄酒质量的结果。</p><p>数据集：葡萄酒质量数据集 </p><p><a href="https://archive.ics.uci.edu/ml/datasets/wine+quality">https://archive.ics.uci.edu/ml/datasets/wine+quality</a></p><p><strong>9.假新闻检测项目</strong></p><p>项目构想：虚假新闻像野火一样传播，这在这个时代是一个大问题。我们可以学习如何将假新闻与真实新闻区分开。我们可以使用监督学习来实现这样的模型。</p><p>数据集：检测虚假新闻数据集 </p><p><a href="https://drive.google.com/file/d/1er9NJTLUA3qnRuyhfzuN0XUsoIC4a-_q/view">https://drive.google.com/file/d/1er9NJTLUA3qnRuyhfzuN0XUsoIC4a-_q/view</a></p><p>源代码：假新闻检测项目 </p><p><a href="https://data-flair.training/blogs/advanced-python-project-detecting-fake-news/">https://data-flair.training/blogs/advanced-python-project-detecting-fake-news/</a></p><p>到目前为止，如果对DataFlair提出的的机器学习项目有任何问题，欢迎留言。</p><p><strong>中级机器学习项目</strong></p><p><strong>1.音乐流派分类机器学习项目</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-16702173124235.png" class="" title="图片"><p>项目构想：该python机器学习项目的思想是开发一个机器学习项目，并自动对音频中的不同音乐流派进行分类。我们需要使用它们的频域和时域低级特征对这些音频文件进行分类。</p><p>源代码：音乐流派分类项目 </p><p><a href="https://data-flair.training/blogs/python-project-music-genre-classification/">https://data-flair.training/blogs/python-project-music-genre-classification/</a></p><p><strong>2.比特币价格预测器项目</strong></p><p>项目构想：比特币价格预测器是一个有用的项目。区块链技术正在发展，并且有许多数字货币在上升。该项目将帮助你使用以前的数据预测比特币的价格。</p><p>数据集：比特币价格预测数据集 </p><p><a href="https://www.kaggle.com/team-ai/bitcoin-price-prediction/version/1">https://www.kaggle.com/team-ai/bitcoin-price-prediction/version/1</a></p><p><strong>3. Uber数据分析项目</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-16702173124236.png" class="" title="图片"><p>项目构想：该项目可用于对超级数据执行数据可视化。该数据集包含纽约市中的450万个超级拾取器。为了分析行程，需要精美地表示很多数据，以便可以进一步改善业务。</p><p>数据集：Uber数据分析数据集 </p><p><a href="https://drive.google.com/file/d/1emopjfEkTt59jJoBH9L9bSdmlDC4AR87/view">https://drive.google.com/file/d/1emopjfEkTt59jJoBH9L9bSdmlDC4AR87/view</a></p><p>源代码：Uber数据分析项目 </p><p><a href="https://data-flair.training/blogs/r-data-science-project-uber-data-analysis/">https://data-flair.training/blogs/r-data-science-project-uber-data-analysis/</a></p><p><strong>4.人格预测项目</strong></p><p>项目构想：Myers Briggs类型指示器是一种个性类型系统，根据内向，直觉，思维和感知能力将一个人分为16个不同的个性。我们可以根据他们在社交媒体上发布的帖子的类型来确定其个性。</p><p>数据集：个性预测数据集 </p><p><a href="https://www.kaggle.com/datasnaek/mbti-type">https://www.kaggle.com/datasnaek/mbti-type</a></p><p><strong>5. Xbox游戏预测项目</strong></p><p>项目构想：人们在搜索时生成的数据可用于预测用户的兴趣。BestBuy消费电子公司已提供了来自用户的数百万次搜索的数据，我们将预测用户最有兴趣购买的Xbox游戏。这将用于向游客推荐游戏。</p><p>数据集：Xbox游戏预测数据集 </p><p><a href="https://www.kaggle.com/c/acm-sf-chapter-hackathon-small/overview">https://www.kaggle.com/c/acm-sf-chapter-hackathon-small/overview</a></p><p><strong>6.信用卡欺诈检测项目</strong></p><p>项目构想：使用卡进行大量交易的公司需要发现系统中的异常情况。该项目旨在建立信用卡欺诈检测模型。我们将使用交易及其标签作为欺诈或非欺诈来检测客户进行的新交易是否为欺诈。</p><p>数据集：信用卡欺诈检测数据集</p><p><a href="https://drive.google.com/file/d/19BOhwz52NUY3dg8XErVYglctpr5sjTy4/view">https://drive.google.com/file/d/19BOhwz52NUY3dg8XErVYglctpr5sjTy4/view</a></p><p>源代码：信用卡欺诈检测项目</p><p><a href="https://data-flair.training/blogs/data-science-machine-learning-project-credit-card-fraud-detection/">https://data-flair.training/blogs/data-science-machine-learning-project-credit-card-fraud-detection/</a></p><p><strong>7.芭比与大脑项目</strong></p><p>项目构想：芭比娃娃等儿童玩具具有一组预定义的单词，可以重复说。我们可以使用机器学习方法使芭比娃娃有一些头脑。当玩具可以用不同的句子理解和说话时，它会更加吸引人。这是一个出色的项目，将改善孩子们的学习过程。</p><p><strong>8.使用机器学习进行客户细分</strong></p><p>项目构想：客户细分是一种根据客户的购买历史，性别，年龄，兴趣等对客户进行细分的技术。获取此信息非常有用，以便商店可以在个性化营销方面获得帮助，并为客户提供相关的信息交易。在该项目的帮助下，公司可以运行特定于用户的活动并提供特定于用户的报价，而不是向所有用户广播相同的报价。</p><p>数据集：客户细分数据集</p><p><a href="https://drive.google.com/file/d/19BOhwz52NUY3dg8XErVYglctpr5sjTy4/view">https://drive.google.com/file/d/19BOhwz52NUY3dg8XErVYglctpr5sjTy4/view</a></p><p>源代码：客户细分项目</p><p><a href="https://data-flair.training/blogs/r-data-science-project-customer-segmentation/">https://data-flair.training/blogs/r-data-science-project-customer-segmentation/</a></p><p>在机器学习项目创意文章的下一部分，我们将为内行人士介绍一些高级项目创意。 </p><p><strong>高级机器学习项目</strong></p><p><strong>1.使用机器学习进行情感分析</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-16702173124237.png" class="" title="图片"><p>项目构想：情感分析是分析用户情感的过程。我们可以将他们的情绪分为正面，负面或中性。了解如何进行情感分析是一个很棒的项目，并且如今已被广泛使用。这是最受欢迎的机器学习项目之一。其背后的原因是每家公司都试图了解客户的情绪，如果客户满意，他们会留下来。该项目可能显示出减少客户流失的途径。</p><p>数据集：情感分析数据集 </p><p><a href="http://ai.stanford.edu/~amaas/data/sentiment/">http://ai.stanford.edu/~amaas/data/sentiment/</a></p><p>源代码：情感分析项目</p><p><a href="https://data-flair.training/blogs/data-science-r-sentiment-analysis-project/">https://data-flair.training/blogs/data-science-r-sentiment-analysis-project/</a></p><p><strong>2.安然调查项目</strong></p><p>项目构想：安然公司（Enron）在2000年倒闭，但可提供数据进行调查。该数据库包含500,000名在公司工作的真实员工的电子邮件，因此数据对于执行数据分析非常有用，许多数据科学家都使用此数据集。</p><p>数据集：安然调查数据集 </p><p><a href="https://www.cs.cmu.edu/~enron/">https://www.cs.cmu.edu/~enron/</a></p><p><strong>3.语音情感识别机器学习项目</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-16702173124238.png" class="" title="图片"><p>项目构想：这是最好的机器学习项目之一。语音情感识别系统使用音频数据。它以语音的一部分作为输入，然后确定说话者以何种情绪说话。我们可以识别出不同的情绪，例如快乐，悲伤，惊讶，生气等。该项目可能有助于在与呼叫中心通话期间识别客户情绪。</p><p>数据集：语音情感识别数据集</p><p><a href="https://drive.google.com/file/d/1wWsrN2Ep7x6lWqOXfr4rpKGYrJhWc8z7/view">https://drive.google.com/file/d/1wWsrN2Ep7x6lWqOXfr4rpKGYrJhWc8z7/view</a></p><p>源代码：语音情感识别项目</p><p><a href="https://data-flair.training/blogs/python-mini-project-speech-emotion-recognition/">https://data-flair.training/blogs/python-mini-project-speech-emotion-recognition/</a></p><p><strong>4.抓非法捕鱼项目</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-16702173124239.png" class="" title="图片"><p>项目构想：这是一个有趣的机器学习项目。海洋上有许多船，船，不可能手动跟踪每个人的活动。这将是一个了不起的项目，它可以通过卫星和地理位置数据识别非法偷猎动物并捕捞捕鱼活动。Global Fishing Watch免费提供实时数据，可用于构建系统。</p><p>数据集：捕捉非法捕鱼数据集 </p><p><a href="https://globalfishingwatch.org/map-and-data/">https://globalfishingwatch.org/map-and-data/</a></p><p><strong>5.使用协同过滤的在线杂货推荐</strong></p><p>项目构想：协作过滤是一项很棒的技术，可根据相似用户的反应来过滤出用户可能喜欢的项目。杂货店推荐系统将是一个使客户意识到自己想要的东西的好项目。</p><p><strong>6.使用机器学习的电影推荐系统</strong></p><img src="/2022/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE/640-167021731242310.png" class="" title="图片"><p>项目构想：推荐系统无处不在，无论是在线购买应用程序，电影流媒体应用程序还是音乐流媒体。他们都根据目标客户推荐产品。电影推荐系统是增强你的作品集的绝佳项目。</p><p>数据集：电影推荐系统数据集 </p><p><a href="https://drive.google.com/file/d/1Dn1BZD3YxgBQJSIjbfNnmCFlDW2jdQGD/view">https://drive.google.com/file/d/1Dn1BZD3YxgBQJSIjbfNnmCFlDW2jdQGD/view</a></p><p>源代码：电影推荐系统项目 </p><p><a href="https://data-flair.training/blogs/data-science-r-movie-recommendation/">https://data-flair.training/blogs/data-science-r-movie-recommendation/</a></p><p><strong>7.车牌自动识别系统</strong></p><p>项目构想：该机器学习项目的目的是检测和识别车辆的牌照号，并读取印在牌照上的牌照号。这可能是用于安全扫描，流量监视等的良好应用程序。</p><p>源代码：自动车牌识别项目</p><p><a href="https://techvidvan.com/tutorials/python-project-license-number-plate-recognition/">https://techvidvan.com/tutorials/python-project-license-number-plate-recognition/</a></p><p>相关报道：</p><p><a href="https://data-flair.training/blogs/machine-learning-project-ideas/">https://data-flair.training/blogs/machine-learning-project-ideas/</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++学习记录</title>
    <link href="/2022/05/18/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/05/18/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li>专注那些我们应该去做的事情，并坚持下去！</li><li>一片飘落的树叶最终落在哪里，决定他的是上帝。至于我们，正如那片树叶一般，去努力想着我们的目标飞行就足够了</li><li>至于上帝的眷顾嘛？大家都知道，机会总是留给有准备的人。只有你朝着梦想去努力追求，才有可能实现梦想，而在困难与挫折面前停滞不前，忧虑苦闷肯定不属于追求梦想的范畴！</li></ul><span id="more"></span><blockquote><p>这几天再 B 站大学看了一边小甲鱼的 C++快速入门，做个记录以便回忆复习。<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=43&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Ps411w73m?p=43&amp;spm_id_from=pageDriver</a></p></blockquote><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数的重载的规则：</p><ul><li>函数名称必须相同。</li><li>参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。</li><li>函数的返回类型可以相同也可以不相同。</li><li>仅仅返回类型不同不足以成为函数的重载。</li></ul><h3 id="C-是如何做到函数重载的"><a href="#C-是如何做到函数重载的" class="headerlink" title="C++ 是如何做到函数重载的"></a>C++ 是如何做到函数重载的</h3><p>C++代码在编译时会根据参数列表对函数进行重命名，例如<code>void Swap(int a, int b)</code>会被重命名为*<code>Swap_int_int</code>，<code>void Swap(float x, float y)</code>会被重命名为*<code>Swap_float_float</code>。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做<strong>重载决议（Overload Resolution）</strong>。</p><p>从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p><p>更详细的细节：<a href="https://blog.csdn.net/qq_41854911/article/details/119360742">https://blog.csdn.net/qq_41854911/article/details/119360742</a></p><h2 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合 Union"></a>联合 Union</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">mima</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> brithday;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ssn;<br>    <span class="hljs-type">char</span>* pet;<br>&#125;;<br></code></pre></td></tr></table></figure><p>联合一次只能对一个成员赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">mima mima_1;<br><br>std::cout&lt;&lt;<span class="hljs-string">&quot;hello world!&quot;</span>&lt;&lt;endl;<br><br>mima_1.brithday = <span class="hljs-number">19883101</span>;<br>std::cout&lt;&lt;mima_1.brithday&lt;&lt;endl;<br>mima_1.pet =(<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;Chaozai&quot;</span>;<br>std::cout&lt;&lt;mima_1.pet&lt;&lt;endl;<br>std::cout&lt;&lt;mima_1.brithday&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="enum-别名"><a href="#enum-别名" class="headerlink" title="enum 别名"></a>enum 别名</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">weekdays</span>&#123;Monday,Tuesday,Wednesday,Thursday,Friday&#125;;<br>   weekdays today;<br><br>   today = Monday; <span class="hljs-comment">//输出0</span><br>   std::cout &lt;&lt; today &lt;&lt;std::endl;<br><br>   today = Thursday; <span class="hljs-comment">//输出3</span><br>   std::cout&lt;&lt;today &lt;&lt;std::endl;<br></code></pre></td></tr></table></figure><blockquote><p>可以配合 switch case 使用</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p>在创建对象，系统会调用一个特殊的方法，即构造器</p></blockquote><p>构造函数与以下方式的常规函数不同：</p><ul><li>构造函数与类本身具有相同的名称</li><li>构造函数没有返回类型</li><li>创建对象时会自动调用构造函数。</li><li>如果我们没有指定构造函数，C ++编译器会为我们生成一个默认构造函数（不需要参数并且有一个空体）。</li></ul><p>….</p><p>创建构造器，需要先把它的声明添加到类里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br><span class="hljs-built_in">Car</span>(<span class="hljs-type">void</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在结束声明后开始定义构造器本身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Car::<span class="hljs-built_in">Car</span>(<span class="hljs-type">void</span>)<br>&#123;<br>    color = <span class="hljs-string">&quot;WHITE&quot;</span>;<br>    engine = <span class="hljs-string">&quot;V8&quot;</span>;<br>    Wheel = <span class="hljs-number">4</span>;<br>    gas_tank = FULL_GAS;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当你的类中没有定义构造器，编译器就会使用如下的语法定义一个：</p><p>ClassName::ClassName(){}</p><h2 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h2><p>构造器用来完成事先的初始化和准备工作（申请分配内存），析构器用来完成事后所必须的清理工作（清理内存）。</p><p>构造器和析构器两者相辅相成，两者有许多共同之处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span><br>&#123;<br>    <span class="hljs-built_in">Car</span>(<span class="hljs-type">void</span>)<br>    ~<span class="hljs-built_in">Car</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在较为复杂的类里，析构器往往至关重要（可能引起内存泄露）。</p><blockquote><p>eg 某个类申请了内存，必须用析构器释放</p></blockquote><h2 id="This-指针"><a href="#This-指针" class="headerlink" title="This 指针"></a>This 指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<br><span class="hljs-type">char</span> fishc;<br><span class="hljs-built_in">Human</span>(<span class="hljs-type">char</span> fishc);<br>&#125;<br>Human::<span class="hljs-built_in">Human</span>(<span class="hljs-type">char</span> fishc)&#123;<br>    fishc = fishc;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时<code>fishc = fishc</code> 我们无法得知哪个 fishc 是类中的属性，哪个 fishc 是参数，这时候就需要 this 指针，<code>this-&gt;fishc = fishc</code>赋值后 this 对应 fishc 为对象中的属性。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>继承机制可以创建一个类的层叠层次结构，使得每一个子类均继承在它的基类里定义的方法和属性。</p><blockquote><p>如以动物为基类的类可以有猪和乌龟两个子类</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span> : <span class="hljs-keyword">public</span> SuperClass&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pig</span>:<span class="hljs-keyword">public</span> Animal&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="继承机制中的构造器和析构器"><a href="#继承机制中的构造器和析构器" class="headerlink" title="继承机制中的构造器和析构器"></a>继承机制中的构造器和析构器</h2><p>按原来的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Animal</span>(std::string theName);<br>    std::string name;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pig</span> : <span class="hljs-keyword">public</span> Animal&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Pig</span>(std::string theName);<br>&#125;<br></code></pre></td></tr></table></figure><p>应该的写法：将 pig 的构造器继承于 animal 的构造器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">Animal::<span class="hljs-built_in">Animal</span>(std::string theName)&#123;<br>    name = theName<br>&#125;<br>Pig::<span class="hljs-built_in">Pig</span>(std::string theName) : <span class="hljs-built_in">Animal</span>(theName)&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初学者注意"><a href="#初学者注意" class="headerlink" title="初学者注意"></a>初学者注意</h2><ul><li>基类和子类之间的关系应该自然而清晰</li><li>构造器的设计要越简明越好</li><li>在设计、定义和使用一个类的时候，应该让它的每个组成部分简单到不能再简单</li><li>析构器的基本用途是对前面做的事进行清理。尤其是使用了动态内存的程序，析构器将至关重要。</li></ul><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>所谓的访问控制，就是 C++提供了一种用来保护类里的方法和属性的手段。保护是指对谁可以调用某个方法和访问某个属性加上一个限制，如果某对象试图调用一个它无权访问的函数，编译器将报错</p><table><thead><tr><th align="center">级别</th><th align="center">允许谁来访问</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">任何代码</td></tr><tr><td align="center">protected</td><td align="center">这个类本身和它的子类</td></tr><tr><td align="center">private</td><td align="center">只有这个类本身</td></tr></tbody></table><p>question:下列代码中的 public 的含义</p><p><code>--- class Pig : public Animal &#123;...&#125;</code></p><ul><li><p>C++不仅允许你对类里定义的方法和属性实施访问控制，还允许你控制子类可以访问基类里的哪些方法和属性。</p></li><li><p>public</p><ul><li>是再告诉编译器：继承的方法和属性的访问级别不发生任何改变——即 public 仍可以被所有代码访问，protected 只能由基类的子类访问，private 则只能由基类本身访问。</li></ul></li><li><p>protected</p><ul><li>子类外部的代码无法通过子类去访问基类中的 public</li></ul></li><li><p>private</p><ul><li>从基类继承来的每一个成员都当成 private 来对待，者意味着只有这个子类可以使用它从基类继承来的元素</li></ul></li></ul><blockquote><p>一般只用 public …….</p></blockquote><h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>当我们的基类里提供了一个通用的函数，但在它的某个子类里需要修改这个方法的实现，在 C++里，覆盖（overriding）就可以做到。</p><p>讲基类中的函数在子类中进行再一次的声明，再一次的实现就可以将继承来的函数覆盖。</p><h2 id="重载方法"><a href="#重载方法" class="headerlink" title="重载方法"></a>重载方法</h2><p>简化编程互作和提高代码可读性的另一种方法是对方法进行重载。</p><p>重载是同一个类之间，覆盖是基类和子类之间。</p><h2 id="友元关系"><a href="#友元关系" class="headerlink" title="友元关系"></a>友元关系</h2><p>可能在某些场合，一个完全无关的类由于某些特殊原因需要访问到某个 protected 成员，甚至某个 private 成员，那该怎么办？</p><p><strong>友元关系</strong>是类之间的一种特殊关系，这种关系不仅允许友元类访问对方的 public 方法和属性，还允许友元访问对方的 protected 和 private 方法和属性。</p><p>声明一个友元关系只需要在类声明里的一个地方加上一条<code>friend class **</code>就行。</p><h2 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Pet</span>(std::string theName);<br>        ~<span class="hljs-built_in">Pet</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">protected</span>:<br>        std::string name;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>&#125;;<br></code></pre></td></tr></table></figure><p>只能从<code>getCount()</code> 的接口访问 count 的值，用 static 关键字后，会在静态存储区分配内存</p><h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><h2 id="C-内存分配方式"><a href="#C-内存分配方式" class="headerlink" title="C++内存分配方式"></a>C++内存分配方式</h2><p>一个由 C&#x2F;C++编译的程序占用的内存分为以下几个部分：<br>1、栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap） ： 一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。（malloc &amp; new）<br>3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、常量存储区 ：常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区：存放函数体的二进制代码。</p><blockquote><p><a href="https://fishc.com.cn/blog-9-1097.html">https://fishc.com.cn/blog-9-1097.html</a></p></blockquote><h2 id="容器——向量-Vector"><a href="#容器——向量-Vector" class="headerlink" title="容器——向量 Vector"></a>容器——向量 Vector</h2><p>。。。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>。。。。</p><h2 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C++预处理器"></a>C++预处理器</h2><ul><li>有时候在头文件较多时，多个文件之间互相 include，这时有些类、变量、函数等等会被声明多次，这种声明将导致编译器报错。</li><li>利用 C++预处理器，我们可以让头文件只在这个类还没有被声明过的情况下才声明它。</li></ul><p><strong>预处理器的条件指令</strong></p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>#if</td><td>如果表达式为真，执行代码</td></tr><tr><td>#else</td><td>如果前面的#if 表达式为假，执行代码</td></tr><tr><td>#elif</td><td>相当于“elseif”</td></tr><tr><td>#endif</td><td>用来标志一个条件指令的结束</td></tr><tr><td>#ifdef</td><td>如果本指令所引用的定义已存在，执行代码</td></tr><tr><td>#ifndef</td><td>如果本指令所引用的定义不存在，执行代码</td></tr></tbody></table><p><strong>可以用预处理来进行代码注释</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">// 一堆代码1</span><br><span class="hljs-comment">// 一堆代码2</span><br><span class="hljs-comment">// 一堆代码3</span><br><span class="hljs-comment">// 一堆代码4</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>可以实现相同量只定义一次</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LOVE_FISHC</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOVE_FISHC</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果 LOVE_FISHC 没有定义则定义之。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LOVE_FISHC</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOVE_FISHC</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;...&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果 LOVE_FISHC 还没有定义，则定义一次 LOVE_FISHC,然后对 Rational.h 做出声明将.改为下划线”RATIONAL_H”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> RATIONAL_H</span><br>#DEFINE RATIONAL_H<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">rational</span>&#123;...&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><strong>命名空间</strong></h2><p>创建的每一个类、函数和变量都只能在一定的区域内使用，而我们所知道最大的区域是全局作用域，最小的区域是一个代码块，eg.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>命名空间其实就是由用户定义的范围，同一个命名空间里的东西只要在这个命名空间有独一无二的名字就行了。如果某个程序有许多不同的头文件或已编译文件，它们又各自声明了许多的东西，命名空间可以为它们提供保护。</p><p>创建命名空间的方法如下（括起来就行，最末尾不要加分号）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> myNamespace<br>&#123;<br><span class="hljs-comment">//全部东西</span><br>&#125;<br></code></pre></td></tr></table></figure><p>命名空间可以让你使用同一个标识符而不会导致冲突：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> author<br>&#123;<br>    std::string person;<br>&#125;<br><span class="hljs-keyword">namespace</span> programmer<br>&#123;<br>    std::string person;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链接和作用域"><a href="#链接和作用域" class="headerlink" title="链接和作用域"></a>链接和作用域</h2><p>当你同时编译多个文件时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -o test main.cpp rational.cpp<br></code></pre></td></tr></table></figure><p>每个源文件都被称为一个翻译单元（translation unit)，在某一个翻译单元里定义的东西在另一个翻译单元里使用正是链接发挥作用的地方。</p><p>作用域、链接和存储类是相互关联的概念，它们有许多共同的术语，只是观察和描述问题的角度不同罢了。</p><h2 id="存储类（storage-class"><a href="#存储类（storage-class" class="headerlink" title="存储类（storage class)"></a>存储类（storage class)</h2><ul><li>每一个变量都有一个存储类，它决定着程序将把变量的值存储在计算机的什么地方、如何存储，以及变量应该有着怎样的作用域。</li><li>默认的存储类是<strong>auto</strong>(自动)，但是我们不会经常看到这个关键字，因为它是默认的</li><li>自动变量存储在称为栈（stack)的临时内存里并有着最小的作用域，当程序执行到语句块或函数末尾的右花括号时，它们将被系统回收（栈回收），不复存在。</li><li>与 auto 不同的是<strong>static</strong>,static 变量在程序的声明周期内将一直保有它的值而不会消亡，因为它们是存储在静态存储区，生命周期为从申请到程序退出（和全局变量一样）。</li><li>static 变量可以有 external 或 internal 链接。</li><li>第三种存储类是<strong>extern</strong>,它在有多个翻译单元时非常重要。这个关键字用来把另一个翻译单元里的某个变量声明为本翻译单元里的一个同名全局变量。</li><li>编译器不会为 extern 变量分配内存，因为在其他地方已经为它分配过内存。</li><li>用 extern 关键字相当于告诉编译器：“请相信我，我发誓我知道这个变量在其他翻译单元里肯定存在，它只是没在这个文件里声明。”</li><li>存储类<strong>register</strong>,它要求编译器把一个变量存储在 CPU 的寄存器里。但有着与自动变量相同的作用域。</li><li>register 变量存储速度最快，但有些编译器可能不允许使用这类变量</li></ul><h2 id="变量的链接和作用域"><a href="#变量的链接和作用域" class="headerlink" title="变量的链接和作用域"></a>变量的链接和作用域</h2><p>使用编译器编译程序时，实际有三步</p><ol><li>执行预处理器指令（带#号的）</li><li>把.cpp 文件编译成.o 文件</li><li>把.o 文件链接成一个可执行文件。</li></ol><p>链接分为三种情况：</p><ol><li>外链接（external)</li><li>内链接 (internal)</li><li>无链接 (none)</li></ol><p><strong>外链接</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">eg.<br><span class="hljs-comment">//this.cpp</span><br><span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//that.cpp</span><br><span class="hljs-type">int</span> i2 = i1;<br></code></pre></td></tr></table></figure><p>在编译 that.cpp 文件时，编译器并不知道 i1 变量的存在。为了解决这个问题，我们可以在 that.cpp 里使用 extern 关键字去访问第一个翻译单元的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//this.cpp</span><br><span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//that.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i1;<br><span class="hljs-type">int</span> i2 = i1;<br></code></pre></td></tr></table></figure><p><strong>内链接</strong></p><p>内链接的含义：在某个翻译单元里定义的东西只能在翻译单元里使用，在任何函数以外定义的静态变量都有内链接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//this.cpp</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> d = <span class="hljs-number">8</span>;<br><span class="hljs-comment">//that.cpp</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> d = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure><p><strong>无链接</strong></p><p>在函数里定义的变量只存在于该函数的内部，根本没有任何链接（none)</p><h2 id="函数模板（泛型编程）"><a href="#函数模板（泛型编程）" class="headerlink" title="函数模板（泛型编程）"></a>函数模板（泛型编程）</h2><p>范型编程技术支持程序员创建函数和类的蓝图，而不是具体的函数和类。</p><p>基本的函数模板语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T param)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//do something</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>第一行代码里，尖括号里的一个<code>classT</code> ，用来告诉编译器：字母 T 将在接下来的函数里代表一种不确定的数据类型。</li><li>关键字 class 并不意味着这个是类，这只是一种约定俗成的写法。</li><li>在告诉计算机 T 是一种类型之后，就可以像对待一种普通数据类型那样使用它了。</li></ol><p>for example:</p><p>交换两个变量的值是几乎所有程序的基本操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;a ,<span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp = a;<br>    a = b;<br>    b = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想用这个函数交换两个 double 类型的变量的值，我们需要增加一个 swap(double &amp;a, double &amp;b)函数，因为 C++支持函数重载，但是我们不得不为每一种数据格式写一种函数。此时，我们只需要为编译器准备一个<strong>模板</strong>即可。</p><p><strong>需要注意的地方：</strong></p><ul><li>创建模板时，还可以用<code>template&lt;typename T&gt;</code>来代替<code>template&lt;class T&gt;</code>，他们的含义是一样的。</li><li>注意，<code>template&lt;class T&gt;</code>中的 class 并不意味着 T 只能是一个类</li><li>不要把函数模板分成原型和实现两个部分（全写一起）</li><li>为明确地表明<code>swap（）</code>是一个函数模板，还可以使用<code>swap&lt;int&gt;(i1,i2)</code>语法来调用这个函数。这将明确地告诉编译器它应该使用哪一种类型。</li></ul><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类模板与函数模板非常相似：同样是由你编写一个类的模板，再由编译器在你第一次使用这个模板时生成实际代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br><br>&#123;<br><span class="hljs-built_in">MyClass</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a , T &amp;b)</span>；</span><br><span class="hljs-function">&#125;；</span><br></code></pre></td></tr></table></figure><p>构造器的实现将是下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyClass&lt;T&gt;::<span class="hljs-built_in">MyClass</span>()<br>&#123;<br>    <span class="hljs-comment">//初始化操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>MyClass</code>是一个类模板，所以不能只写出<code>MyClass::MyClass()</code>,编译器需要你在这里给出一种与<code>MyClass()</code>配合使用的数据类型，必须在尖括号里提供它。因为没有确定的数据类型可以提供，所以使用一个 T 作为占位符即可。</p><p><strong>注意：</strong></p><p>C++并没有限制只能使用一个类型占位符，如果类模板需要一种以上的类型，根据具体情况多使用几个占位符即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>    &#123;<br>        <span class="hljs-comment">//... ...</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>在实例化的时候我们只需要这么做： <code>MyClass&lt;int,float&gt;myClass;</code></p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>引入内联函数的目的是解决程序中函数调用的效率问题。</p><p>内联函数从源代码看有函数的结构，而在编译后，却不具备函数的性质。编译时，类似宏替换，使用函数体替换调用处的函数名。</p><p>一般在代码中用 inline 修饰，但能否形成内联函数，需要看编译器对该函数定义的具体处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(intx ,<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y+z;<br>&#125;<br></code></pre></td></tr></table></figure><p>在程序中，调用其函数时，该函数在编译时被替代，而不像一般函数那样是在运行时被调用。</p><p>在创建类模板时，避免类声明和类定义相分离的一个好办法是使用内联方法。</p><p>在类里，内联方法的基本含义是在声明该方法的同时还对它进行定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br>    <span class="hljs-built_in">Person</span>(std::string name)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;name = name;<br>    &#125;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了可以更好地帮助编译器处理类模板之外，使用内联方法还有一个很好的作用：可以让你少打些字并让源代码的可读性变得更好（把所有东西都直接写到类里）。</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就自动调用该函数，以实现相应的运算。，也就是说运算符的重载是定义函数实现的。<strong>运算符重载实质上是函数的重载。</strong></p><p>重载运算符的函数一般格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">函数类型 <span class="hljs-keyword">operator</span> 运算符名称（形参表列）<br>&#123;<br>    对运算符的重载处理<br>&#125;<br></code></pre></td></tr></table></figure><p>例如我们可以重载运算符+，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span> a ,<span class="hljs-type">int</span> b)<br>&#123;<br>    <span class="hljs-keyword">return</span>(a-b);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>C++不允许用户自己定义新的运算符，只能对已有的 C++运算符进行重载。</strong></li><li>除了以下五个不允许重载外，其他运算符都允许重载。<ul><li>.（成员访问运算符）</li><li>.*（成员指针访问运算符）</li><li>::（域运算符）</li><li>sizeof（尺寸运算符）</li><li>?:（条件运算符）</li></ul></li><li>重载不能改变运算符运算对象（操作数）个数</li><li>重载不能改变运算符的优先级别</li><li>重载不能改变运算符的结合性</li><li>重载运算符的函数不能有默认的参数。</li><li>重载运算符必须和用户定义的自定义类型的对象一起使用。也就是说，参数不能全部都是 C++的标准类型，这样约定是为了防止用户修改用于标准类型结构的运算符性质）。</li></ol><h3 id="运算符重载函数作为类友元函数"><a href="#运算符重载函数作为类友元函数" class="headerlink" title="运算符重载函数作为类友元函数"></a>运算符重载函数作为类友元函数</h3><p><strong>“+”运算符是双目运算符，为什么例子中的重载函数只有一个参数？</strong></p><p>答：实际上，运算符重载函数有两个参数，但由于重载函数是 Complex 类中的成员函数，有一个参数是隐含着的，运算符函数是用 this 指针隐式地访问类对象的成员的。</p><ul><li><code>return Complex(real+c2.real,imag+c2.imag);</code></li><li><code>return Complex(this-&gt;real+c2.real,this-&gt;imag+c2.imag);</code></li><li><code>return Complex(c1.real+c2.real,c1.imag+c2.imag);</code></li></ul><p>运算符重载除了可以作为类的成员函数外，还可以式非成员函数：放在类外，做 Complex 类的友元函数存在</p><h4 id="一些小-TIPS"><a href="#一些小-TIPS" class="headerlink" title="一些小 TIPS"></a><strong>一些小 TIPS</strong></h4><ul><li>千万不要仅仅因为“我懂得这么做”而去重载一个操作符，应该只在有必要的时候，比如实现一种新的数据类型时，才重载操作符。</li><li>重载操作符的目的是为了让代码更容易阅读和理解。令人遗憾的是，这个技巧常常被人滥用。</li><li>在重载操作符时，千万不要让它们失去原始的意义，你完全重载”+”然后对它进行减法操作，但这决不是创意的表现，在公司这员工必须被开除。</li></ul><h3 id="重载-lt-lt-操作符（插入器）"><a href="#重载-lt-lt-操作符（插入器）" class="headerlink" title="重载&lt;&lt;操作符（插入器）"></a>重载&lt;&lt;操作符（插入器）</h3><blockquote><p>把一个数据插入到流中的函数都是插入器</p></blockquote><h2 id="多继承-multi-inheritance"><a href="#多继承-multi-inheritance" class="headerlink" title="多继承(multi inheritance)"></a>多继承(multi inheritance)</h2><p><strong>什么时候需要用多继承？</strong></p><p>一个 student 不仅当 student,还当 teacher（助教），则 student 同时继承 teacher 和 student 类，此时就需要使用多继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TeachingStudent</span> : <span class="hljs-keyword">public</span> Student, <span class="hljs-keyword">public</span> Teacher<br>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>要求：创建一个由<code>Person</code>,<code>Teacher</code>,<code>Student</code>和<code>Teachingstudent</code>构成的类层次关系。</p><h2 id="虚继承（virtual-inheritance"><a href="#虚继承（virtual-inheritance" class="headerlink" title="虚继承（virtual inheritance)"></a>虚继承（virtual inheritance)</h2><p>在<code>TeachingStudent</code>继承自<code>Student</code>和<code>Teacher</code>时，可能有继承的同名属性的情况</p><p>通过虚继承某个基类，就是在告诉编译器：从当前这个类再派生出来的子类只能拥有那个基类的一个实例。</p><p>虚继承的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Person<br>&#123;...&#125;<br></code></pre></td></tr></table></figure><h2 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *x<br>x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1000</span>]<br><span class="hljs-keyword">delete</span>[] x;<br>x = <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p>如果地址值(x)丢失了，则会发生内存泄漏,地址值会因为很多原因丢失，比如因为一个指针变量被无意中改写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *x;<br>x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3000</span>];<br>x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4000</span>];<br><span class="hljs-keyword">delete</span>[] x;<br>x = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>这是导致内存泄漏的情况之一。</p><p>另一种导致内存泄漏的情况是用来保存内存块的地址的指针变量作用域问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    My Class *x;<br>    x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当 foo()函数结束时，指针变量 x 将超出它的作用域，这意味着它将不复存在，它的值会丢失。</p><p>两种方法解决这种情况：</p><p>第一种是在 return 语句之前的某个地方插入一条 delete x 语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyClass *x;<br>    x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();<br>    <span class="hljs-keyword">delete</span> x;<br>    x = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种是让函数把内存块的地址返回给它的调用者：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">MyClass* <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MyClass* x;<br>    x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态内存不存在作用域的问题，一旦被分配，内存块就可以在程序的任何地方使用。</p><p>因为动态内存没有作用域，所以必须由程序员来跟踪它们的使用情况，并在不需要用到它们的时候把它们及时归还给系统。</p><p>特别需要注意，虽然动态分配的内存块没有作用域，但是用来保存其地址的指针变量是受作用域影响的。</p><p>程序出错</p><p>程序出错分为两类：</p><ul><li>编译时错误</li><li>运行时错误</li></ul><p><strong>建议：</strong></p><ol><li>保持一种风格，一旦决定要如何命名变量和函数、要按何种格式编写代码、如何缩进代码块等，就应该一种保持下去。</li><li>认真对待编译器给出的错误&#x2F;警告信息</li><li>三思而后行：开始写代码前先画流程图</li><li>注意检查最基本的语法</li><li>把可能有问题的代码行改为注释</li><li>换一个环境或者开发工具试试</li><li>检查自己是否已经把所有必要的头文件都 include 进来，调用不熟悉的函数前查看相关文档，确定该函数需要哪些头文件。</li><li>留意变量的作用域和命名空间</li><li>休息一下</li><li>多使用调试工具，要多使用调试器。</li><li>避免错误的另一个办法就是把调试好的代码另外保存起来并不再改动它，然后把代码划分成各个模块，用它们（在你能确保它们都没问题的情况下）搭建新的应用程序，会让你减少很多开发和调试的时间。</li></ol><p><strong>运行时错误</strong></p><ul><li>保持并培养一种良好的变成风格</li><li>多用注释，用好注释，要注意注释和代码保持同步，也不要做无谓的注释。</li><li>注意操作符的优先级，做保险的方法是用括号来确保这种</li><li>千万不要忘记对用户输入和文件输入进行合法性检查</li><li>不要做任何假设</li><li>把程序划分成一些比较小的单元模块测试，程序越长就越难以测试，只要条件允许，就应该把一个比较大的程序划分成一些了比较小的单元模块来分别加以测试。</li></ul><p><strong>让函数返回错误代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( condition )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>eg.在写一个 factorial 函数的时候可能会出现超界的情况，这时候我们可以引用 climits 头文件，该头文件列出了各种数据类型在给定操作系统上的取值范围，并且把每种数据类型的最大可取值和最小可取值都分别定义为一个常量供我们比较。</p><p>SHORT_MAX 整数最大值, SHORT_MIN 整数最小值, USHORT_MAX 无符号整数最大值</p><h2 id="assert-函数和异常捕获"><a href="#assert-函数和异常捕获" class="headerlink" title="assert 函数和异常捕获"></a>assert 函数和异常捕获</h2><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><ul><li>C 语言和 C++都有一个专门为调试而准备的工具函数，就是 assert()函数</li><li>这个函数在 C 语言的 assert.h 库文件里定义，所以包含到 C++程序里我们用以下的语句：<ul><li><code>#include&lt;cassert&gt;</code></li></ul></li><li>assert()函数需要一个参数，它将测试这个输入参数的真&#x2F;假状态</li></ul><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>基本使用思路：</p><ol><li>安排一些 C++代码（try 语句）去尝试某些事——尤其是那些可能会失败的事（比如打开一个文件或申请一些内存。</li><li>如果发生问题，就抛出一个异常（throw)</li><li>再安排一些代码(catch 语句)去捕获这个异常并进行相应的处理。</li></ol><p>捕获异常的基本语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">//Do something</span><br>    <span class="hljs-comment">//Throw an exception an error.</span><br>&#125;<br><span class="hljs-keyword">catch</span><br>&#123;<br>    <span class="hljs-comment">//Do whatever.</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Pay attention! 每条 try 语句至少要有一条配对的 catch 语句。必须定义 catch 语句以便让它接受一个特定类型的参数。</li><li>C++还允许我们定义多条 catch 语句，让每条 catch 语句分别对应着一种可能的异常类型:<ul><li>catch(int e) { …}</li><li>catch(bool e) {…}</li><li>catch(…) {…}</li></ul></li><li>最后一条可以捕获任意的异常</li><li>在程序里，我们用 throw 保留字来抛出一个异常：throw 1;</li><li>在某个 try 语句块里执行过 throw 语句，它后面的所有语句（截止到这个 try 语句末尾）将永远不会被执行。</li><li>与使用一个条件语句或 return 语句相比，采用异常处理机制的好处是它可以把程序的正常功能和逻辑与出错处理部分清晰地划分开而不是让它们混杂在一起。</li></ul><h3 id="如何让函数抛出异常"><a href="#如何让函数抛出异常" class="headerlink" title="如何让函数抛出异常"></a>如何让函数抛出异常</h3><p>定义一个函数时明确地表明你想让它抛出一个异常，为了表明你想让它抛出哪种类型的异常，可以使用如下所示语法：</p><p><code>type functionName(arguments) throw(type);</code></p><p>如果没有使用这种语法来定义函数，就意味着函数可以抛出任意类型的异常。</p><p>注：有些编译器不支持这种语法，则可胜利 throw(type)部分。</p><p><strong>TIPS:</strong></p><ol><li>只用异常处理来确定可能不正常的情况</li><li>构造器和析构器最好不要使用异常</li><li>如果 try 语句无法找到与之匹配的 catch 语句块，它抛出的异常将中止程序的执行。</li><li>在 C++标准库里有一个名为 exception 的文件，该文件声明了一个 exception 的基类。可以用这个基类创建个人的子类以管理异常，有经验的程序员常常这么做，而如此抛出或捕获 exception 类或其子类的对象。</li><li>如果你打算使用对象作为异常，请记住这样一条原则：以“值传递”方式抛出异常，以“引用传递”方式捕获异常对象。</li></ol><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p>new 可以申请动态内存并返回动态内存的地址</p><ul><li>如果没有足够的可用内存空间？<ul><li>那么 new 语句将抛出 std::bad_alloc 异常！</li></ul></li><li>在用完内存块之后，应该用 delete 语句把它还给内存池。另外作为一种附加的保险措施，在释放了内存块之后还应该把与之关联的指针设置为 NULL。</li></ul><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *x = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span> []x;<br>x = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>在 delete 后加上一个[]来表示删除一整个数组（回收该数组对应的内存）</p><h2 id="副本构造器"><a href="#副本构造器" class="headerlink" title="副本构造器"></a>副本构造器</h2><p>编译器将生成必要的代码把“源”对象各属性的值分别赋值给“目标”对象的对应成员。这种赋值行为称之为逐位赋值（bitwise copy)</p><p>这种行为在绝大多数场合都没有问题，但如果某些成员变量是指针的话，问题就来了：成员对象进行逐位复制的结果是你将拥有两个一模一样的实例，而这两个副本里的同名指针会指向相同的地址。在删除其中一个对象时，它包含的指针也将被删除，但另一个副本（对象）还在引用这个指针，就会出问题！</p><p>分析如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">MyClass obj1;<br>MyClass obj2;<br>obj2 = obj1;<br></code></pre></td></tr></table></figure><p>前两行代码创建出了两个 MyClass 类的实例 obj1 和 obj2。第三行代码把 obj1 的值赋值给了 obj2，这里就会埋下祸根！如何才能截获这个赋值操作并告诉它应该如何处理那些指针呢？</p><h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>我们可以重载“&#x3D;”操作符，在其中对指针进行处理：</p><p>—<code>MyClass &amp;operator = (const MyClass &amp;rhs);</code></p><p>上述语句告诉问这个方法所预期的输入参数应该是一个<code>MyClass</code>类型的、不可改变的引用。</p><p>用<code>const</code>把那个引用声明为一个常量确保万无一失（以免被 copy 的对象被修改）。</p><p>改写下测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">MyClass obj1;<br>MyClass obj2 = obj1;<br></code></pre></td></tr></table></figure><ul><li>这与之前的区别很细微，刚才是先创建两个对象，然后再把 obj1 赋值给 obj2.</li><li>现在是先创建一个实例 obj1，然后再创建实例 obj2 的同时用 obj1 的值对它进行初始化。</li><li>虽然看上去差不多，但是编译器却生成完全不同的代码：编译器将在 MyClass 类里寻找一个副本构造器(copy constructor),如果找不到，它会自行创建一个。</li><li>即使我们对赋值操作符进行了重载，由编译器创建的副本构造器仍以”逐位复制”的方式把 obj1 赋值给 obj2。</li><li>在这种情况下，即使已经在类中重载了赋值操作符，暗藏隐患的“逐位复制”行为还是会发生。</li><li>因此要亲自定义一个副本构造器，而不是让编译器自动生成。<ul><li><code>MyClass(const MyClass &amp;rhs);</code></li></ul></li><li>这个构造器需要一个固定不变<code>（const)</code>的<code>MyClass</code>类型的引用作为输入参数，就像赋值操作符那样。<strong>因为它是一个构造器，因此不需要返回类型</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo常用命令</title>
    <link href="/2022/05/12/hexo%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/12/hexo%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>本文章记录了 Hexo 使用过程中的常用的命令</p><span id="more"></span><h1 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a><strong>hexo 常用命令</strong></h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 新建文章</span><br><span class="hljs-attribute">hexo</span> n<br><br><span class="hljs-comment"># 清除缓存</span><br>hexo clean<br><br><span class="hljs-comment"># 生成静态页面+部署</span><br>hexo d -g<span class="hljs-comment"># 等同：hexo g &amp;&amp; hexo d</span><br><span class="hljs-comment"># 生成静态网页</span><br>hexo g<br><span class="hljs-comment"># 部署</span><br>hexo d<br><br><span class="hljs-comment"># 启动服务器预览</span><br>hexo s<br></code></pre></td></tr></table></figure><h2 id="插件卸载与安装"><a href="#插件卸载与安装" class="headerlink" title="插件卸载与安装"></a>插件卸载与安装</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 查看插件</span><br><span class="hljs-built_in">npm</span> list<br><br><span class="hljs-comment"># 安装插件</span><br><span class="hljs-built_in">npm</span> install hexo-xxx-xxx --save<br><br><span class="hljs-comment"># 卸载插件</span><br><span class="hljs-built_in">npm</span> uninstall hexo-xxx-xxx --save<br></code></pre></td></tr></table></figure><p>插件将被安装在 node_moudules&#x2F;目录下</p><p>卸载操作会删除 node_moudules&#x2F;目录下对应的插件文件</p><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 新建一个网站</span><br><span class="hljs-variable">$ </span>hexo init [folder]<br></code></pre></td></tr></table></figure><p>如果没有设置<code>folder</code>，Hexo 默认在<strong>当前文件夹</strong>建立网站</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 新建一篇文章,文章名称和标题为 [title],文章采用 [layout] 布局</span><br>$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>会在目录<code>source/_posts</code>下生成 [title].md 文件，[title].md 文件的顶部会使用—分割区域，也称作 Front matter 区<br>如果没有设置 layout 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替（一般默认是 post）。<br>如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># eg</span><br>$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;post title with whitespace&quot;</span><br></code></pre></td></tr></table></figure><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"># 生成静态文件<br>$ hexo <span class="hljs-keyword">generate</span><br>$ hexo g<br></code></pre></td></tr></table></figure><p>执行 <code>$ hexo g</code>后会在站点根目录下生成<code>public</code>文件夹, hexo 会将<code>/blog/source/</code>下面的<code>.md</code>后缀的文件编译为<code>.html</code>后缀的文件,存放在<code>/blog/public/</code>路径下</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>启动服务器（常用于调试）</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br>hexo s<br></code></pre></td></tr></table></figure><p>默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82Hexo">http://localhost:4000/。Hexo</a> 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p><table><thead><tr><th align="center">选项</th><th>描述</th><th align="center">eg</th></tr></thead><tbody><tr><td align="center">-p, –port</td><td>重设端口</td><td align="center">hexo s -p 5000</td></tr><tr><td align="center">-s, –static</td><td>只使用静态文件</td><td align="center"></td></tr><tr><td align="center">-l, –log</td><td>启动日记记录，使用覆盖记录格式</td><td align="center"></td></tr><tr><td align="center">-i</td><td>自定义 IP</td><td align="center">hexo s -i 192.168.1.1</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>部署网站,将本地数据部署到远端服务器(如 github、coding)</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-g, –generate</td><td align="center">部署之前预先生成静态文件</td></tr></tbody></table><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">渲染文件<br>hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-o, –output</td><td align="center">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">hexo</span> migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 迁移内容。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>清除缓存,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的 public 文件夹</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></td></tr></table></figure><p>清除缓存文件 <code>(db.json</code>) 和已生成的静态文件 (<code>public)</code>。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">hexo</span> list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>安全模式</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-comment">--safe</span><br></code></pre></td></tr></table></figure><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> --<span class="hljs-literal">debug</span><br></code></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-comment">--silent</span><br></code></pre></td></tr></table></figure><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-comment">--config custom.yml</span><br></code></pre></td></tr></table></figure><p>自定义配置文件的路径，执行后将不再使用 _config.yml。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-comment">--draft</span><br></code></pre></td></tr></table></figure><p>显示 source&#x2F;_drafts 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hexo --cwd <span class="hljs-regexp">/path/</span>to/cwd<br></code></pre></td></tr></table></figure><p>自定义当前工作目录（Current working directory）的路径。</p><p>转自：<a href="https://blog.csdn.net/tian_ci/article/details/93397337">https://blog.csdn.net/tian_ci/article/details/93397337</a></p><p><a href="https://hexo.io/zh-cn/docs/">hexo 官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>命令汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/05/12/Git/"/>
    <url>/2022/05/12/Git/</url>
    
    <content type="html"><![CDATA[<p>本文章记录了 git 的常用命令，包括初始化 git 设置、git commit、git push、git pull、版本回退、查看日志等</p><span id="more"></span><h1 id="Git-命令汇总"><a href="#Git-命令汇总" class="headerlink" title="Git 命令汇总"></a>Git 命令汇总</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>用户名和邮箱代表身份</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>.前有空格，添加所有文件到暂存区</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span>  .<br></code></pre></td></tr></table></figure><p>添加具体文件到暂存区</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> readme.txt<br></code></pre></td></tr></table></figure><p>告诉仓库，文件已经提交到仓库</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>查看是否还有文件未提交</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><p>恢复文件</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">git <span class="hljs-built_in">restore</span> readme.txt<br></code></pre></td></tr></table></figure><p>可以看到文件的修改内容</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">diff</span> readme.txt<br></code></pre></td></tr></table></figure><p>版本回退</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^     回退到上个版本</span><br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^^    回退到前个版本</span><br>git reser <span class="hljs-comment">--hard HEAD~100  回退到前100个版本</span><br></code></pre></td></tr></table></figure><p>可以查看所有的日志</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git  <span class="hljs-built_in">ref</span>log<br></code></pre></td></tr></table></figure><p>查到对应的版本号后 eg. 6fcfc89</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard  6fcfc89</span><br></code></pre></td></tr></table></figure><p><strong>工作区：</strong>就是你在电脑上看到的目录，比如目录下 test.git 里的文件(.git 隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。<br><strong>版本库(Repository)：</strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是 stage(暂存区)，还有 Git 为我们自动创建了第一个分支 master,以及指向 master 的一个指针 HEAD。</p><h2 id="创建一个新的版本库"><a href="#创建一个新的版本库" class="headerlink" title="创建一个新的版本库"></a>创建一个新的版本库</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">echo</span> <span class="hljs-string">&quot;# test&quot;</span> &gt;&gt; README.md<br><span class="hljs-symbol">git</span> init<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> README.md<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><span class="hljs-symbol">git</span> branch -M main<br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/username/test.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin main<br></code></pre></td></tr></table></figure><h2 id="Push-版本库"><a href="#Push-版本库" class="headerlink" title="Push 版本库"></a>Push 版本库</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote add origin https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/username/</span>test.git<br>git branch -M main<br>git push -u origin main<br></code></pre></td></tr></table></figure><p>把本地库的内容推送到远程，使用 git push 命令，实际上是把当前分支 master 推送到远程。由于远程库是空的，我们第一次推送 master 分支时，加上了 –u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来,在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在 github 页面中看到远程库的内容已经和本地一模一样了。</p><h2 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h2><p>以上都是用的 master 分支，下面来创建 dev 分支，然后切换到 dev 分支上</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>dev -<span class="hljs-keyword">b </span>表示创建并切换相当于以下两条命令<br>git <span class="hljs-keyword">branch </span>deb<br>git checkout dev<br></code></pre></td></tr></table></figure><p>在 dev 分支上提交后回到 main 分支，可以看到 main 分支上内容没有改变现在我们可以把 dev 分支上的内容合并到分支 master 上了，可以在 master 分支上，使用如下命令 git merge dev 。git merge 命令用于合并指定分支到当前分支上，合并后，再查看可以看到和 dev 最新提交的是完全一样的。</p><p>总结创建与合并分支命令如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fortran">　　查看分支：git branch<br><br>　　创建分支：git branch <span class="hljs-keyword">name</span><br><br>　　切换分支：git checkout <span class="hljs-keyword">name</span><br><br>　　创建+切换分支：git checkout –b <span class="hljs-keyword">name</span><br><br>　　合并某分支到当前分支：git <span class="hljs-built_in">merge</span> <span class="hljs-keyword">name</span><br><br>　　删除分支：git branch –d <span class="hljs-keyword">name</span><br></code></pre></td></tr></table></figure><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常合并分支时，git 一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff 来禁用”Fast forward”模式。</p><ol><li>创建一个 dev 分支。</li><li>修改 readme.txt 内容。</li><li>添加到暂存区。</li><li>切换回主分支(master)。</li><li>合并 dev 分支，使用命令 git merge –no-ff -m “注释” dev</li><li>查看历史记录</li></ol><p>git push origin master &#x2F;&#x2F;git push origin dev(次分支不必要同步，可以先合并到主分支再 push)</p><ol><li>首先，可以试图用 git push origin branch-name 推送自己的修改.</li><li>如果推送失败，则因为远程分支比你的本地更新早，需要先用 git pull 试图合并。</li><li>如果合并有冲突，则需要解决冲突，并在本地提交。再用 git push origin branch-name 推送</li></ol><p>git 提供了一种<strong>强制上传</strong>的方式：git push -f ，它会忽略版本不一致等问题，强制将本地库上传的远程库，但是一定要谨慎使用，<strong>因为-f 会用本地库覆盖掉远程库</strong>，如果远程库上有重要更新，或者有其他同伴做的修改,也都会被覆盖，所以一定要在确定无严重后果的前提下使用此操作。</p><h2 id="命令汇总"><a href="#命令汇总" class="headerlink" title="命令汇总"></a>命令汇总</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs maxima">　　<span class="hljs-built_in">mkdir</span>：         XX (创建一个空目录 XX指目录名)<br><br>　　pwd：          显示当前目录的路径。<br><br>　　git init          把当前的目录变成可以管理的git仓库，生成隐藏.git文件。<br><br>　　git add XX       把xx文件添加到暂存区去。<br><br>　　git commit –m “XX”  提交文件 –m 后面的是注释。<br><br>　　git <span class="hljs-built_in">status</span>        查看仓库状态<br><br>　　git <span class="hljs-built_in">diff</span>  XX      查看XX文件修改了那些内容<br><br>　　git <span class="hljs-built_in">log</span>          查看历史记录<br><br>　　git <span class="hljs-built_in">reset</span>  --hard HEAD^ 或者 git <span class="hljs-built_in">reset</span>  --hard HEAD~ 回退到上一个版本<br><br>　　(如果想回退到<span class="hljs-number">100</span>个版本，使用git <span class="hljs-built_in">reset</span> –hard HEAD~<span class="hljs-number">100</span> )<br><br>　　cat XX         查看XX文件内容<br><br>　　git reflog       查看历史记录的版本号id<br><br>　　git checkout -- XX  把XX文件在工作区的修改全部撤销。<br><br>　　git rm XX          删除XX文件<br><br>　　git remote add <span class="hljs-built_in">origin</span> https://github.com/tugenhua0707/testgit 关联一个远程库<br><br>　　git <span class="hljs-built_in">push</span> –u(第一次要用-u 以后不需要) <span class="hljs-built_in">origin</span> master 把当前master分支推送到远程库<br><br>　　git clone https://github.com/tugenhua0707/testgit  从远程库中克隆<br><br>　　git checkout –b dev  创建dev分支 并切换到dev分支上<br><br>　　git branch  查看当前所有的分支<br><br>　　git checkout master 切换回master分支<br><br>　　git merge dev    在当前的分支上合并dev分支<br><br>　　git branch –d dev 删除dev分支<br><br>　　git branch name  创建分支<br><br>　　git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作<br><br>　　git stash list 查看所有被隐藏的文件列表<br><br>　　git stash <span class="hljs-built_in">apply</span> 恢复被隐藏的文件，但是内容不删除<br><br>　　git stash drop 删除文件<br><br>　　git stash <span class="hljs-built_in">pop</span> 恢复文件的同时 也删除文件<br><br>　　git remote 查看远程库的信息<br><br>　　git remote –v 查看远程库的详细信息<br><br>　　git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master  Git会把master分支推送到远程库对应的远程分支上<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>命令汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
