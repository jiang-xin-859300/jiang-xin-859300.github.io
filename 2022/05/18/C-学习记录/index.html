

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jiang Xin">
  <meta name="keywords" content="Robot ROS C++ Python">
  
    <meta name="description" content="这几天再B站大学看了一边小甲鱼的C++快速入门，做个记录以便回忆复习。https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1Ps411w73m?p&#x3D;43&amp;spm_id_from&#x3D;pageDriver 视频里小甲鱼这么说  专注那些我们应该去做的事情，并坚持下去！ 一片飘落的树叶最终落在哪里，决定他的是上帝。至于我们，正如那片树叶一般，去努力想着我们的目标飞行就足够了 至于上帝">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习记录">
<meta property="og:url" content="http://jiang-xin-859300.github.io/2022/05/18/C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Make a dream">
<meta property="og:description" content="这几天再B站大学看了一边小甲鱼的C++快速入门，做个记录以便回忆复习。https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1Ps411w73m?p&#x3D;43&amp;spm_id_from&#x3D;pageDriver 视频里小甲鱼这么说  专注那些我们应该去做的事情，并坚持下去！ 一片飘落的树叶最终落在哪里，决定他的是上帝。至于我们，正如那片树叶一般，去努力想着我们的目标飞行就足够了 至于上帝">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-18T13:33:41.000Z">
<meta property="article:modified_time" content="2022-11-24T11:50:32.154Z">
<meta property="article:author" content="Jiang Xin">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++学习记录 - Make a dream</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jiang-xin-859300.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++学习记录"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-18 21:33" pubdate>
          2022年5月18日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          107 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++学习记录</h1>
            
            
              <div class="markdown-body">
                
                <p>这几天再B站大学看了一边小甲鱼的C++快速入门，做个记录以便回忆复习。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ps411w73m?p=43&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1Ps411w73m?p=43&amp;spm_id_from=pageDriver</a></p>
<p>视频里小甲鱼这么说</p>
<ul>
<li>专注那些我们应该去做的事情，并坚持下去！</li>
<li>一片飘落的树叶最终落在哪里，决定他的是上帝。至于我们，正如那片树叶一般，去努力想着我们的目标飞行就足够了</li>
<li>至于上帝的眷顾嘛？大家都知道，机会总是留给有准备的人。只有你朝着梦想去努力追求，才有可能实现梦想，而在困难与挫折面前停滞不前，忧虑苦闷肯定不属于追求梦想的范畴！</li>
</ul>
<span id="more"></span>

<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数的重载的规则：</p>
<ul>
<li>函数名称必须相同。</li>
<li>参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。</li>
<li>函数的返回类型可以相同也可以不相同。</li>
<li>仅仅返回类型不同不足以成为函数的重载。</li>
</ul>
<h3 id="C-是如何做到函数重载的"><a href="#C-是如何做到函数重载的" class="headerlink" title="C++ 是如何做到函数重载的"></a>C++ 是如何做到函数重载的</h3><p>C++代码在编译时会根据参数列表对函数进行重命名，例如<code>void Swap(int a, int b)</code>会被重命名为_<code>Swap_int_int</code>，<code>void Swap(float x, float y)</code>会被重命名为_<code>Swap_float_float</code>。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做<strong>重载决议（Overload Resolution）</strong>。</p>
<p>从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。</p>
<p>更详细的细节：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41854911/article/details/119360742">https://blog.csdn.net/qq_41854911/article/details/119360742</a></p>
<h2 id="联合Union"><a href="#联合Union" class="headerlink" title="联合Union"></a>联合Union</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">mima</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> brithday;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ssn;</span><br><span class="line">    <span class="type">char</span>* pet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>联合一次只能对一个成员赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mima mima_1;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">mima_1.brithday = <span class="number">19883101</span>;</span><br><span class="line">std::cout&lt;&lt;mima_1.brithday&lt;&lt;endl;</span><br><span class="line">mima_1.pet =(<span class="type">char</span>*)<span class="string">&quot;Chaozai&quot;</span>;</span><br><span class="line">std::cout&lt;&lt;mima_1.pet&lt;&lt;endl;</span><br><span class="line">std::cout&lt;&lt;mima_1.brithday&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="enum-别名"><a href="#enum-别名" class="headerlink" title="enum 别名"></a>enum 别名</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">weekdays</span>&#123;Monday,Tuesday,Wednesday,Thursday,Friday&#125;;</span><br><span class="line">   weekdays today;</span><br><span class="line">   </span><br><span class="line">   today = Monday; <span class="comment">//输出0</span></span><br><span class="line">   std::cout &lt;&lt; today &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">   today = Thursday; <span class="comment">//输出3</span></span><br><span class="line">   std::cout&lt;&lt;today &lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以配合switch case 使用</p>
</blockquote>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote>
<p>在创建对象，系统会调用一个特殊的方法，即构造器</p>
</blockquote>
<p>构造函数与以下方式的常规函数不同：</p>
<ul>
<li>构造函数与类本身具有相同的名称</li>
<li>构造函数没有返回类型</li>
<li>创建对象时会自动调用构造函数。</li>
<li>如果我们没有指定构造函数，C ++编译器会为我们生成一个默认构造函数（不需要参数并且有一个空体）。</li>
</ul>
<p>….</p>
<p>创建构造器，需要先把它的声明添加到类里</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">	<span class="built_in">Car</span>(<span class="type">void</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在结束声明后开始定义构造器本身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Car::<span class="built_in">Car</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    color = <span class="string">&quot;WHITE&quot;</span>;</span><br><span class="line">    engine = <span class="string">&quot;V8&quot;</span>;</span><br><span class="line">    Wheel = <span class="number">4</span>;</span><br><span class="line">    gas_tank = FULL_GAS;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当你的类中没有定义构造器，编译器就会使用如下的语法定义一个： </p>
<p>ClassName::ClassName(){}</p>
<h2 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h2><p>构造器用来完成事先的初始化和准备工作（申请分配内存），析构器用来完成事后所必须的清理工作（清理内存）。</p>
<p>构造器和析构器两者相辅相成，两者有许多共同之处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Car</span>(<span class="type">void</span>)</span><br><span class="line">    ~<span class="built_in">Car</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在较为复杂的类里，析构器往往至关重要（可能引起内存泄露）。</p>
<blockquote>
<p>eg某个类申请了内存，必须用析构器释放</p>
</blockquote>
<h2 id="This指针"><a href="#This指针" class="headerlink" title="This指针"></a>This指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">	<span class="type">char</span> fishc;</span><br><span class="line">	<span class="built_in">Human</span>(<span class="type">char</span> fishc);</span><br><span class="line">&#125;</span><br><span class="line">Human::<span class="built_in">Human</span>(<span class="type">char</span> fishc)&#123;</span><br><span class="line">    fishc = fishc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<code>fishc = fishc</code> 我们无法得知哪个fishc 是类中的属性，哪个fishc是参数，这时候就需要this指针，<code>this-&gt;fishc = fishc</code>赋值后this对应fishc为对象中的属性。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>继承机制可以创建一个类的层叠层次结构，使得每一个子类均继承在它的基类里定义的方法和属性。</p>
<blockquote>
<p> 如以动物为基类的类可以有猪和乌龟两个子类</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> : <span class="keyword">public</span> SuperClass&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span>:<span class="keyword">public</span> Animal&#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="继承机制中的构造器和析构器"><a href="#继承机制中的构造器和析构器" class="headerlink" title="继承机制中的构造器和析构器"></a>继承机制中的构造器和析构器</h2><p>按原来的写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Animal</span>(std::string theName);</span><br><span class="line">    	std::string name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Pig</span>(std::string theName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该的写法：将pig的构造器继承于animal的构造器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal::<span class="built_in">Animal</span>(std::string theName)&#123;</span><br><span class="line">    name = theName</span><br><span class="line">&#125;</span><br><span class="line">Pig::<span class="built_in">Pig</span>(std::string theName) : <span class="built_in">Animal</span>(theName)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初学者注意"><a href="#初学者注意" class="headerlink" title="初学者注意"></a>初学者注意</h2><ul>
<li>基类和子类之间的关系应该自然而清晰</li>
<li>构造器的设计要越简明越好</li>
<li>在设计、定义和使用一个类的时候，应该让它的每个组成部分简单到不能再简单</li>
<li>析构器的基本用途是对前面做的事进行清理。尤其是使用了动态内存的程序，析构器将至关重要。</li>
</ul>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>所谓的访问控制，就是C++提供了一种用来保护类里的方法和属性的手段。保护是指对谁可以调用某个方法和访问某个属性加上一个限制，如果某对象试图调用一个它无权访问的函数，编译器将报错</p>
<table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">允许谁来访问</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">任何代码</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">这个类本身和它的子类</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">只有这个类本身</td>
</tr>
</tbody></table>
<p>question:下列代码中的public的含义</p>
<p><code>--- class Pig : public Animal &#123;...&#125;</code></p>
<ul>
<li><p>C++不仅允许你对类里定义的方法和属性实施访问控制，还允许你控制子类可以访问基类里的哪些方法和属性。</p>
</li>
<li><p>public</p>
<ul>
<li>是再告诉编译器：继承的方法和属性的访问级别不发生任何改变——即public仍可以被所有代码访问，protected 只能由基类的子类访问，private则只能由基类本身访问。</li>
</ul>
</li>
<li><p>protected</p>
<ul>
<li>子类外部的代码无法通过子类去访问基类中的public</li>
</ul>
</li>
<li><p>private </p>
<ul>
<li>从基类继承来的每一个成员都当成private来对待，者意味着只有这个子类可以使用它从基类继承来的元素</li>
</ul>
</li>
</ul>
<blockquote>
<p>一般只用public …….</p>
</blockquote>
<h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>当我们的基类里提供了一个通用的函数，但在它的某个子类里需要修改这个方法的实现，在C++里，覆盖（overriding）就可以做到。</p>
<p>讲基类中的函数在子类中进行再一次的声明，再一次的实现就可以将继承来的函数覆盖。</p>
<h2 id="重载方法"><a href="#重载方法" class="headerlink" title="重载方法"></a>重载方法</h2><p>简化编程互作和提高代码可读性的另一种方法是对方法进行重载。</p>
<p>重载是同一个类之间，覆盖是基类和子类之间。</p>
<h2 id="友元关系"><a href="#友元关系" class="headerlink" title="友元关系"></a>友元关系</h2><p>可能在某些场合，一个完全无关的类由于某些特殊原因需要访问到某个protected成员，甚至某个private成员，那该怎么办？</p>
<p><strong>友元关系</strong>是类之间的一种特殊关系，这种关系不仅允许友元类访问对方的public方法和属性，还允许友元访问对方的protected和private方法和属性。</p>
<p> 声明一个友元关系只需要在类声明里的一个地方加上一条<code>friend class **</code>就行。</p>
<h2 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Pet</span>(std::string theName);</span><br><span class="line">        ~<span class="built_in">Pet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        std::string name;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只能从<code>getCount()</code> 的接口访问count的值，用static 关键字后，会在静态存储区分配内存</p>
<h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><h2 id="C-内存分配方式"><a href="#C-内存分配方式" class="headerlink" title="C++内存分配方式"></a>C++内存分配方式</h2><p>一个由C&#x2F;C++编译的程序占用的内存分为以下几个部分：<br>1、栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap） ： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。（malloc &amp; new）<br>3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。<br>4、常量存储区 ：常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区：存放函数体的二进制代码。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://fishc.com.cn/blog-9-1097.html">https://fishc.com.cn/blog-9-1097.html</a></p>
</blockquote>
<h2 id="容器——向量Vector"><a href="#容器——向量Vector" class="headerlink" title="容器——向量Vector"></a>容器——向量Vector</h2><p>。。。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>。。。。</p>
<h2 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C++预处理器"></a>C++预处理器</h2><ul>
<li>有时候在头文件较多时，多个文件之间互相include，这时有些类、变量、函数等等会被声明多次，这种声明将导致编译器报错。</li>
<li>利用C++预处理器，我们可以让头文件只在这个类还没有被声明过的情况下才声明它。</li>
</ul>
<p><strong>预处理器的条件指令</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>#if</td>
<td>如果表达式为真，执行代码</td>
</tr>
<tr>
<td>#else</td>
<td>如果前面的#if表达式为假，执行代码</td>
</tr>
<tr>
<td>#elif</td>
<td>相当于“elseif”</td>
</tr>
<tr>
<td>#endif</td>
<td>用来标志一个条件指令的结束</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果本指令所引用的定义已存在，执行代码</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果本指令所引用的定义不存在，执行代码</td>
</tr>
</tbody></table>
<p><strong>可以用预处理来进行代码注释</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">// 一堆代码1</span></span><br><span class="line">	<span class="comment">// 一堆代码2</span></span><br><span class="line">	<span class="comment">// 一堆代码3</span></span><br><span class="line">	<span class="comment">// 一堆代码4</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>可以实现相同量只定义一次</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOVE_FISHC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOVE_FISHC</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果LOVE_FISHC没有定义则定义之。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOVE_FISHC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOVE_FISHC</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;...&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果LOVE_FISHC还没有定义，则定义一次LOVE_FISHC,然后对Rational.h做出声明将.改为下划线”RATIONAL_H”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> RATIONAL_H</span></span><br><span class="line">#DEFINE RATIONAL_H</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rational</span>&#123;...&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><strong>命名空间</strong></h2><p>创建的每一个类、函数和变量都只能在一定的区域内使用，而我们所知道最大的区域是全局作用域，最小的区域是一个代码块，eg.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间其实就是由用户定义的范围，同一个命名空间里的东西只要在这个命名空间有独一无二的名字就行了。如果某个程序有许多不同的头文件或已编译文件，它们又各自声明了许多的东西，命名空间可以为它们提供保护。</p>
<p>创建命名空间的方法如下（括起来就行，最末尾不要加分号）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myNamespace</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//全部东西</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命名空间可以让你使用同一个标识符而不会导致冲突：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> author</span><br><span class="line">&#123;</span><br><span class="line">    std::string person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> programmer</span><br><span class="line">&#123;</span><br><span class="line">    std::string person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链接和作用域"><a href="#链接和作用域" class="headerlink" title="链接和作用域"></a>链接和作用域</h2><p>当你同时编译多个文件时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o test main.cpp rational.cpp</span><br></pre></td></tr></table></figure>

<p>每个源文件都被称为一个翻译单元（translation unit)，在某一个翻译单元里定义的东西在另一个翻译单元里使用正是链接发挥作用的地方。</p>
<p>作用域、链接和存储类是相互关联的概念，它们有许多共同的术语，只是观察和描述问题的角度不同罢了。</p>
<h2 id="存储类（storage-class"><a href="#存储类（storage-class" class="headerlink" title="存储类（storage class)"></a>存储类（storage class)</h2><ul>
<li>每一个变量都有一个存储类，它决定着程序将把变量的值存储在计算机的什么地方、如何存储，以及变量应该有着怎样的作用域。</li>
<li>默认的存储类是<strong>auto</strong>(自动)，但是我们不会经常看到这个关键字，因为它是默认的</li>
<li>自动变量存储在称为栈（stack)的临时内存里并有着最小的作用域，当程序执行到语句块或函数末尾的右花括号时，它们将被系统回收（栈回收），不复存在。</li>
<li>与auto不同的是<strong>static</strong>,static变量在程序的声明周期内将一直保有它的值而不会消亡，因为它们是存储在静态存储区，生命周期为从申请到程序退出（和全局变量一样）。</li>
<li>static变量可以有external或internal链接。</li>
<li>第三种存储类是<strong>extern</strong>,它在有多个翻译单元时非常重要。这个关键字用来把另一个翻译单元里的某个变量声明为本翻译单元里的一个同名全局变量。</li>
<li>编译器不会为extern变量分配内存，因为在其他地方已经为它分配过内存。</li>
<li>用extern关键字相当于告诉编译器：“请相信我，我发誓我知道这个变量在其他翻译单元里肯定存在，它只是没在这个文件里声明。”</li>
<li>存储类<strong>register</strong>,它要求编译器把一个变量存储在CPU的寄存器里。但有着与自动变量相同的作用域。</li>
<li>register变量存储速度最快，但有些编译器可能不允许使用这类变量</li>
</ul>
<h2 id="变量的链接和作用域"><a href="#变量的链接和作用域" class="headerlink" title="变量的链接和作用域"></a>变量的链接和作用域</h2><p>使用编译器编译程序时，实际有三步</p>
<ol>
<li>执行预处理器指令（带#号的）</li>
<li>把.cpp文件编译成.o文件</li>
<li>把.o文件链接成一个可执行文件。</li>
</ol>
<p>链接分为三种情况：</p>
<ol>
<li>外链接（external)</li>
<li>内链接  (internal)</li>
<li>无链接  (none)</li>
</ol>
<p><strong>外链接</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg.</span><br><span class="line"><span class="comment">//this.cpp</span></span><br><span class="line"><span class="type">int</span> i1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//that.cpp</span></span><br><span class="line"><span class="type">int</span> i2 = i1;</span><br></pre></td></tr></table></figure>

<p>在编译that.cpp文件时，编译器并不知道i1变量的存在。为了解决这个问题，我们可以在that.cpp里使用extern关键字去访问第一个翻译单元的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this.cpp</span></span><br><span class="line"><span class="type">int</span> i1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//that.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i1;</span><br><span class="line"><span class="type">int</span> i2 = i1;</span><br></pre></td></tr></table></figure>

<p><strong>内链接</strong></p>
<p>内链接的含义：在某个翻译单元里定义的东西只能在翻译单元里使用，在任何函数以外定义的静态变量都有内链接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> d = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//that.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> d = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p><strong>无链接</strong></p>
<p>在函数里定义的变量只存在于该函数的内部，根本没有任何链接（none)</p>
<h2 id="函数模板（泛型编程）"><a href="#函数模板（泛型编程）" class="headerlink" title="函数模板（泛型编程）"></a>函数模板（泛型编程）</h2><p>范型编程技术支持程序员创建函数和类的蓝图，而不是具体的函数和类。</p>
<p>基本的函数模板语法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>第一行代码里，尖括号里的一个<code>classT</code> ，用来告诉编译器：字母T将在接下来的函数里代表一种不确定的数据类型。</li>
<li>关键字class并不意味着这个是类，这只是一种约定俗成的写法。</li>
<li>在告诉计算机T是一种类型之后，就可以像对待一种普通数据类型那样使用它了。</li>
</ol>
<p>for example:</p>
<p>交换两个变量的值是几乎所有程序的基本操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp;a ,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想用这个函数交换两个double类型的变量的值，我们需要增加一个swap(double &amp;a, double &amp;b)函数，因为C++支持函数重载，但是我们不得不为每一种数据格式写一种函数。此时，我们只需要为编译器准备一个<strong>模板</strong>即可。</p>
<p><strong>需要注意的地方：</strong></p>
<ul>
<li>创建模板时，还可以用<code>template&lt;typename T&gt;</code>来代替<code>template&lt;class T&gt;</code>，他们的含义是一样的。</li>
<li>注意，<code>template&lt;class T&gt;</code>中的class并不意味着T只能是一个类</li>
<li>不要把函数模板分成原型和实现两个部分（全写一起）</li>
<li>为明确地表明<code>swap（）</code>是一个函数模板，还可以使用<code>swap&lt;int&gt;(i1,i2)</code>语法来调用这个函数。这将明确地告诉编译器它应该使用哪一种类型。</li>
</ul>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p> 类模板与函数模板非常相似：同样是由你编写一个类的模板，再由编译器在你第一次使用这个模板时生成实际代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">		<span class="built_in">MyClass</span>();</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;a , T &amp;b)</span>；</span></span><br><span class="line"><span class="function">&#125;；</span></span><br></pre></td></tr></table></figure>

<p>构造器的实现将是下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass&lt;T&gt;::<span class="built_in">MyClass</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>MyClass</code>是一个类模板，所以不能只写出<code>MyClass::MyClass()</code>,编译器需要你在这里给出一种与<code>MyClass()</code>配合使用的数据类型，必须在尖括号里提供它。因为没有确定的数据类型可以提供，所以使用一个T作为占位符即可。</p>
<p><strong>注意：</strong></p>
<p>C++并没有限制只能使用一个类型占位符，如果类模板需要一种以上的类型，根据具体情况多使用几个占位符即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//... ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在实例化的时候我们只需要这么做： <code>MyClass&lt;int,float&gt;myClass;</code></p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>引入内联函数的目的是解决程序中函数调用的效率问题。</p>
<p>内联函数从源代码看有函数的结构，而在编译后，却不具备函数的性质。编译时，类似宏替换，使用函数体替换调用处的函数名。</p>
<p>一般在代码中用inline修饰，但能否形成内联函数，需要看编译器对该函数定义的具体处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(intx ,<span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y+z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序中，调用其函数时，该函数在编译时被替代，而不像一般函数那样是在运行时被调用。</p>
<p>在创建类模板时，避免类声明和类定义相分离的一个好办法是使用内联方法。</p>
<p>在类里，内联方法的基本含义是在声明该方法的同时还对它进行定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Person</span>(std::string name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了可以更好地帮助编译器处理类模板之外，使用内联方法还有一个很好的作用：可以让你少打些字并让源代码的可读性变得更好（把所有东西都直接写到类里）。</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就自动调用该函数，以实现相应的运算。，也就是说运算符的重载是定义函数实现的。<strong>运算符重载实质上是函数的重载。</strong></p>
<p> 重载运算符的函数一般格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符名称（形参表列）</span><br><span class="line">&#123;</span><br><span class="line">    对运算符的重载处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如我们可以重载运算符+，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">int</span> a ,<span class="type">int</span> b)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span>(a-b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载。</strong></li>
<li>除了以下五个不允许重载外，其他运算符都允许重载。<ul>
<li>.（成员访问运算符）</li>
<li>.*（成员指针访问运算符）</li>
<li>::（域运算符）</li>
<li>sizeof（尺寸运算符）</li>
<li>?:（条件运算符）</li>
</ul>
</li>
<li>重载不能改变运算符运算对象（操作数）个数</li>
<li>重载不能改变运算符的优先级别  </li>
<li>重载不能改变运算符的结合性</li>
<li>重载运算符的函数不能有默认的参数。</li>
<li>重载运算符必须和用户定义的自定义类型的对象一起使用。也就是说，参数不能全部都是C++的标准类型，这样约定是为了防止用户修改用于标准类型结构的运算符性质）。</li>
</ol>
<h3 id="运算符重载函数作为类友元函数"><a href="#运算符重载函数作为类友元函数" class="headerlink" title="运算符重载函数作为类友元函数"></a>运算符重载函数作为类友元函数</h3><p><strong>“+”运算符是双目运算符，为什么例子中的重载函数只有一个参数？</strong></p>
<p>答：实际上，运算符重载函数有两个参数，但由于重载函数是Complex类中的成员函数，有一个参数是隐含着的，运算符函数是用this指针隐式地访问类对象的成员的。</p>
<ul>
<li><code>return Complex(real+c2.real,imag+c2.imag);</code></li>
<li><code>return Complex(this-&gt;real+c2.real,this-&gt;imag+c2.imag);</code></li>
<li><code>return Complex(c1.real+c2.real,c1.imag+c2.imag);</code></li>
</ul>
<p>运算符重载除了可以作为类的成员函数外，还可以式非成员函数：放在类外，做Complex类的友元函数存在</p>
<h4 id="一些小TIPS"><a href="#一些小TIPS" class="headerlink" title="一些小TIPS"></a><strong>一些小TIPS</strong></h4><ul>
<li>千万不要仅仅因为“我懂得这么做”而去重载一个操作符，应该只在有必要的时候，比如实现一种新的数据类型时，才重载操作符。</li>
<li>重载操作符的目的是为了让代码更容易阅读和理解。令人遗憾的是，这个技巧常常被人滥用。</li>
<li>在重载操作符时，千万不要让它们失去原始的意义，你完全重载”+”然后对它进行减法操作，但这决不是创意的表现，在公司这员工必须被开除。</li>
</ul>
<h3 id="重载-lt-lt-操作符（插入器）"><a href="#重载-lt-lt-操作符（插入器）" class="headerlink" title="重载&lt;&lt;操作符（插入器）"></a>重载&lt;&lt;操作符（插入器）</h3><blockquote>
<p>把一个数据插入到流中的函数都是插入器</p>
</blockquote>
<h2 id="多继承-multi-inheritance"><a href="#多继承-multi-inheritance" class="headerlink" title="多继承(multi inheritance)"></a>多继承(multi inheritance)</h2><p><strong>什么时候需要用多继承？</strong></p>
<p>一个student不仅当student,还当teacher（助教），则student同时继承teacher和student类，此时就需要使用多继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TeachingStudent</span> : <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>要求：创建一个由<code>Person</code>,<code>Teacher</code>,<code>Student</code>和<code>Teachingstudent</code>构成的类层次关系。</p>
<h2 id="虚继承（virtual-inheritance"><a href="#虚继承（virtual-inheritance" class="headerlink" title="虚继承（virtual inheritance)"></a>虚继承（virtual inheritance)</h2><p>在<code>TeachingStudent</code>继承自<code>Student</code>和<code>Teacher</code>时，可能有继承的同名属性的情况</p>
<p>通过虚继承某个基类，就是在告诉编译器：从当前这个类再派生出来的子类只能拥有那个基类的一个实例。</p>
<p>虚继承的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>



<h2 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x</span><br><span class="line">x = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1000</span>]</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line">x = <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>如果地址值(x)丢失了，则会发生内存泄漏,地址值会因为很多原因丢失，比如因为一个指针变量被无意中改写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x;</span><br><span class="line">x = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3000</span>];</span><br><span class="line">x = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">4000</span>];</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line">x = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>这是导致内存泄漏的情况之一。</p>
<p>另一种导致内存泄漏的情况是用来保存内存块的地址的指针变量作用域问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    My Class *x;</span><br><span class="line">    x = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当foo()函数结束时，指针变量x将超出它的作用域，这意味着它将不复存在，它的值会丢失。</p>
<p>两种方法解决这种情况：</p>
<p>第一种是在return 语句之前的某个地方插入一条delete x语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass *x;</span><br><span class="line">    x = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">    x = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是让函数把内存块的地址返回给它的调用者：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass* <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass* x;</span><br><span class="line">    x = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态内存不存在作用域的问题，一旦被分配，内存块就可以在程序的任何地方使用。</p>
<p>因为动态内存没有作用域，所以必须由程序员来跟踪它们的使用情况，并在不需要用到它们的时候把它们及时归还给系统。</p>
<p>特别需要注意，虽然动态分配的内存块没有作用域，但是用来保存其地址的指针变量是受作用域影响的。</p>
<p>程序出错</p>
<p>程序出错分为两类：</p>
<ul>
<li>编译时错误</li>
<li>运行时错误</li>
</ul>
<p><strong>建议：</strong></p>
<ol>
<li>保持一种风格，一旦决定要如何命名变量和函数、要按何种格式编写代码、如何缩进代码块等，就应该一种保持下去。</li>
<li>认真对待编译器给出的错误&#x2F;警告信息</li>
<li>三思而后行：开始写代码前先画流程图</li>
<li>注意检查最基本的语法</li>
<li>把可能有问题的代码行改为注释</li>
<li>换一个环境或者开发工具试试</li>
<li>检查自己是否已经把所有必要的头文件都include进来，调用不熟悉的函数前查看相关文档，确定该函数需要哪些头文件。</li>
<li>留意变量的作用域和命名空间</li>
<li>休息一下</li>
<li>多使用调试工具，要多使用调试器。</li>
<li>避免错误的另一个办法就是把调试好的代码另外保存起来并不再改动它，然后把代码划分成各个模块，用它们（在你能确保它们都没问题的情况下）搭建新的应用程序，会让你减少很多开发和调试的时间。</li>
</ol>
<p><strong>运行时错误</strong></p>
<ul>
<li>保持并培养一种良好的变成风格</li>
<li>多用注释，用好注释，要注意注释和代码保持同步，也不要做无谓的注释。</li>
<li>注意操作符的优先级，做保险的方法是用括号来确保这种</li>
<li>千万不要忘记对用户输入和文件输入进行合法性检查</li>
<li>不要做任何假设</li>
<li>把程序划分成一些比较小的单元模块测试，程序越长就越难以测试，只要条件允许，就应该把一个比较大的程序划分成一些了比较小的单元模块来分别加以测试。</li>
</ul>
<p><strong>让函数返回错误代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( condition )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg.在写一个factorial函数的时候可能会出现超界的情况，这时候我们可以引用climits头文件，该头文件列出了各种数据类型在给定操作系统上的取值范围，并且把每种数据类型的最大可取值和最小可取值都分别定义为一个常量供我们比较。</p>
<p>SHORT_MAX 整数最大值,    SHORT_MIN 整数最小值, USHORT_MAX 无符号整数最大值</p>
<h2 id="assert函数和异常捕获"><a href="#assert函数和异常捕获" class="headerlink" title="assert函数和异常捕获"></a>assert函数和异常捕获</h2><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><ul>
<li>C语言和C++都有一个专门为调试而准备的工具函数，就是assert()函数</li>
<li>这个函数在C语言的assert.h库文件里定义，所以包含到C++程序里我们用以下的语句：<ul>
<li><code>#include&lt;cassert&gt;</code></li>
</ul>
</li>
<li>assert()函数需要一个参数，它将测试这个输入参数的真&#x2F;假状态</li>
</ul>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>基本使用思路：</p>
<ol>
<li>安排一些C++代码（try语句）去尝试某些事——尤其是那些可能会失败的事（比如打开一个文件或申请一些内存。</li>
<li>如果发生问题，就抛出一个异常（throw)</li>
<li>再安排一些代码(catch语句)去捕获这个异常并进行相应的处理。</li>
</ol>
<p>捕获异常的基本语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Do something</span></span><br><span class="line">    <span class="comment">//Throw an exception an error.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Do whatever.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Pay attention! 每条try语句至少要有一条配对的catch语句。必须定义catch语句以便让它接受一个特定类型的参数。</li>
<li>C++还允许我们定义多条catch语句，让每条catch语句分别对应着一种可能的异常类型:<ul>
<li>catch(int e) { …}</li>
<li>catch(bool e) {…}</li>
<li>catch(…) {…}</li>
</ul>
</li>
<li>最后一条可以捕获任意的异常</li>
<li>在程序里，我们用throw保留字来抛出一个异常：throw 1; </li>
<li>在某个try语句块里执行过throw语句，它后面的所有语句（截止到这个try语句末尾）将永远不会被执行。</li>
<li>与使用一个条件语句或return语句相比，采用异常处理机制的好处是它可以把程序的正常功能和逻辑与出错处理部分清晰地划分开而不是让它们混杂在一起。</li>
</ul>
<h3 id="如何让函数抛出异常"><a href="#如何让函数抛出异常" class="headerlink" title="如何让函数抛出异常"></a>如何让函数抛出异常</h3><p>定义一个函数时明确地表明你想让它抛出一个异常，为了表明你想让它抛出哪种类型的异常，可以使用如下所示语法：</p>
<p>​	<code>type functionName(arguments)  throw(type);</code></p>
<p>如果没有使用这种语法来定义函数，就意味着函数可以抛出任意类型的异常。</p>
<p>注：有些编译器不支持这种语法，则可胜利throw(type)部分。</p>
<p><strong>TIPS:</strong></p>
<ol>
<li>只用异常处理来确定可能不正常的情况</li>
<li>构造器和析构器最好不要使用异常</li>
<li>如果try语句无法找到与之匹配的catch语句块，它抛出的异常将中止程序的执行。</li>
<li>在C++标准库里有一个名为exception的文件，该文件声明了一个exception的基类。可以用这个基类创建个人的子类以管理异常，有经验的程序员常常这么做，而如此抛出或捕获exception类或其子类的对象。</li>
<li>如果你打算使用对象作为异常，请记住这样一条原则：以“值传递”方式抛出异常，以“引用传递”方式捕获异常对象。</li>
</ol>
<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p>new可以申请动态内存并返回动态内存的地址</p>
<ul>
<li>如果没有足够的可用内存空间？<ul>
<li>那么new语句将抛出std::bad_alloc异常！</li>
</ul>
</li>
<li>在用完内存块之后，应该用delete语句把它还给内存池。另外作为一种附加的保险措施，在释放了内存块之后还应该把与之关联的指针设置为NULL。</li>
</ul>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> []x;</span><br><span class="line">x = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>在delete后加上一个[]来表示删除一整个数组（回收该数组对应的内存）</p>
<h2 id="副本构造器"><a href="#副本构造器" class="headerlink" title="副本构造器"></a>副本构造器</h2><p>编译器将生成必要的代码把“源”对象各属性的值分别赋值给“目标”对象的对应成员。这种赋值行为称之为逐位赋值（bitwise copy) </p>
<p>这种行为在绝大多数场合都没有问题，但如果某些成员变量是指针的话，问题就来了：成员对象进行逐位复制的结果是你将拥有两个一模一样的实例，而这两个副本里的同名指针会指向相同的地址。在删除其中一个对象时，它包含的指针也将被删除，但另一个副本（对象）还在引用这个指针，就会出问题！</p>
<p>分析如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2;</span><br><span class="line">obj2 = obj1;</span><br></pre></td></tr></table></figure>

<p>前两行代码创建出了两个MyClass类的实例obj1和obj2。第三行代码把obj1的值赋值给了obj2，这里就会埋下祸根！如何才能截获这个赋值操作并告诉它应该如何处理那些指针呢？</p>
<h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>我们可以重载“&#x3D;”操作符，在其中对指针进行处理：</p>
<p>—<code>MyClass &amp;operator = (const MyClass &amp;rhs);</code></p>
<p>上述语句告诉问这个方法所预期的输入参数应该是一个<code>MyClass</code>类型的、不可改变的引用。</p>
<p>用<code>const</code>把那个引用声明为一个常量确保万无一失（以免被copy的对象被修改）。</p>
<p>改写下测试代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2 = obj1;</span><br></pre></td></tr></table></figure>

<ul>
<li>这与之前的区别很细微，刚才是先创建两个对象，然后再把obj1赋值给obj2.</li>
<li>现在是先创建一个实例obj1，然后再创建实例obj2的同时用obj1的值对它进行初始化。</li>
<li>虽然看上去差不多，但是编译器却生成完全不同的代码：编译器将在MyClass类里寻找一个副本构造器(copy constructor),如果找不到，它会自行创建一个。</li>
<li>即使我们对赋值操作符进行了重载，由编译器创建的副本构造器仍以”逐位复制”的方式把obj1赋值给obj2。</li>
<li>在这种情况下，即使已经在类中重载了赋值操作符，暗藏隐患的“逐位复制”行为还是会发生。</li>
<li>因此要亲自定义一个副本构造器，而不是让编译器自动生成。<ul>
<li><code>MyClass(const MyClass &amp;rhs);</code></li>
</ul>
</li>
<li>这个构造器需要一个固定不变<code>（const)</code>的<code>MyClass</code>类型的引用作为输入参数，就像赋值操作符那样。<strong>因为它是一个构造器，因此不需要返回类型</strong></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C/" class="category-chain-item">C++</a>
  
  
    <span>></span>
    
  <a href="/categories/C/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="category-chain-item">学习记录</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/">#学习</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++学习记录</div>
      <div>http://jiang-xin-859300.github.io/2022/05/18/C-学习记录/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jiang Xin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/20/wsl2-ubuntu-22-04/" title="wsl2 ubuntu-22.04 C++环境配置">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">wsl2 ubuntu-22.04 C++环境配置</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/14/%E5%A7%9A%E7%8E%89%E5%B3%B0%E5%8C%BB%E7%94%9F%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB/" title="姚玉峰医生个人分享">
                        <span class="hidden-mobile">姚玉峰医生个人分享</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
